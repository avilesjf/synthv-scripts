local SCRIPT_TITLE = '..Harmonies'

--[[

lua file name: HarmonyPanel.lua

Copy selected groups to a new track and transpose all included notes
Add only one track or multiple tracks depending on user selection.

1/ Transpose all notes in current key scale -7 to +7 (C, D to B)
2/ Display current key scale found in selected group(s)
3/ Use current track to duplicate new track (to keep track voice)
4/ Generate AI retakes for each new group harmony
5/ Panel display introduced with Synthesizer V version 2.1.2b1

Notice: Works only with script panel 
		introduced with Synthesizer V version >= 2.1.2b1

2025 - JF AVILES
--]]

function getClientInfo()
	return {
		name = SV:T(SCRIPT_TITLE),
		category = "_JFA_Panels",
		author = "JFAVILES",
		versionNumber = 1,
		minVersion = 131329,
		type = "SidePanelSection"
	}
end

-- Generated by JFA TranslateScripts.lua
function getTranslations(langCode)
	return getArrayLanguageStrings()[langCode]
end

-- Generated by JFA TranslateScripts.lua
function getArrayLanguageStrings()
	return {
		["en-us"] = {
			{"1 note", "1 note"},
			{"Selected", "Selected"},
			{"Major", "Major"},
			{"Track H", "Track H"},
			{"2 notes", "2 notes"},
			{"3 notes", "3 notes"},
			{"Octaves", "Octaves"},
			{"Fixed", "Fixed"},
			{"Version", "Version"},
			{"author", "author"},
			{"Generate harmonies", "Generate harmonies"},
			{"Select at least one group!", "Select at least one group!"},
			{"major", "major"},
			{"natural minor", "natural minor"},
			{"blues major", "blues major"},
			{"dorian", "dorian"},
			{"phrygian", "phrygian"},
			{"melodic minor", "melodic minor"},
			{"harmonic minor", "harmonic minor"},
			{"ionian", "ionian"},
			{"locrian", "locrian"},
			{"lydian", "lydian"},
			{"mixolydian", "mixolydian"},
			{"aeolian", "aeolian"},
			{"blues_minor", "blues_minor"},
			{"japanese", "japanese"},
			{"chinese", "chinese"},
			{"chinese 2", "chinese 2"},
			{"indian", "indian"},
			{"hungarian_major", "hungarian_major"},
			{"Groups", "Groups"},
			{"No common scale key found!", "No common scale key found!"},
			{"groups", "groups"},
			{"group", "group"},
			{"No scale key found!", "No scale key found!"},
			{"Relative minor keys: ", "Relative minor keys: "},
			{"Track: ", "Track: "},
			{"Error: No scale key found!", "Error: No scale key found!"},
			{"Error: Position into scale error!", "Error: Position into scale error!"},
			{"No group selected!", "No group selected!"},
			{"Select a key scale", "Select a key scale"},
			{"Key scale type", "Key scale type"},
			{"Get current voice for new tracks", "Get current voice for new tracks"},
			{"Harmony type", "Harmony type"},
			{"Transpose (-7 to +7)", "Transpose (-7 to +7)"},
			{"Apply", "Apply"},
		},
	}
end

-- Define a class  "NotesObject"
NotesObject = {
	hostinfo = nil,
	osType = "",
	osName = "",
	hostName = "",
	languageCode = "", 
	hostVersion = "",
	hostVersionNumber = 0,	
	displayVersion = false,			-- display version & author
	playBack = nil,
	allScalesActive = false,		-- true to list all scales
    scales = {},
	errorMessages = {},
	keyNames = {},					-- {"C", "Db", "D", ...
	currentKeyNames = {},			-- {"C", "Db", "D", ...
	keysInScale = {},
	relativeKeys = {},				-- {{"C","Am"},{"Db","Bbm"},{"D","Bm"},
	transposition = {},
	transpositionRefLabel = 1,		-- {Label = SV:T("1 note"), Position = 8, RefData = {"+7", "+6", "+5",...
	transpositionRefPosition = 2,	-- Position = 8,
	transpositionRefData = 3,		-- RefData = {"+7", "+6", "+5",...
	transpositionDoubleNotesList = {},	-- {"+7", "+6", "+5",...
	pitchSelected = "",				-- Selected: 0 or 1 or +3, +5 etc.
	pitchSelectedLabel = SV:T("Selected") .. ": ",
	pitchSelectedType = "pitch",
	isOnlyOneKeyFound = false,
	isTrackKeyFound = false,
	posKeyInScaleForm = 0,
	SEP_KEYS = "/",
	keyScaleChoice = {},
	relativeMinorScalekeysChoice = {},
	relativeMinorScalekeys = "",
	keyScaleFound = "",
	keyScaleTypeFound  = 1,		-- for Major scale
	keyScaleTypeTitleFound  = "",
	keyScaleTypeValuesMajor = {0,2,4,5,7,9,11,12}, -- major
	keyScaleTypeValuesFound = {0,2,4,5,7,9,11,12}, -- default major
	trackNameHarmony = "",
	isTrackClone = false,
	newTrackRef = nil,
	tracks = {},
	trackListChoice = {},
	outputLevelDefaultValue = 0,
	isCurrentVoiceTrack = true,
	languageOverride = "", 		-- Language override (Empty string => disabled)
	retakes = true, 			-- Enable AI retakes
	newDurationRetakes = true,	-- AI retakes
	newPitchRetakes = true,		-- AI retakes
	newTimbreRetakes = true,	-- AI retakes
	DEBUG = false,
	defaultKeyFoundMessage = "",
	groupsSelected = {},
	scalesList = {},
	controls = {}, -- controls panel
	applyButtonValue = nil,		-- button
	statusTextValue = nil,		-- text panel
	colors = {},
	currentColorPos = 0,
	currentColor = "",
	logs = {}	
}

-- Constructor method for the NotesObject class
function NotesObject:new()
    local notesObject = {}
    setmetatable(notesObject, self)
    self.__index = self
	
	self.playBack = SV:getPlayback()
	self:getHostInformations()
	self.keyScaleTypeTitleFound  = SV:T("Major")
	self.trackNameHarmony = SV:T("Track H")
	
	self.keyNames = {"C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"}
	self.currentKeyNames = {"C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"}
	self.relativeKeys = {{"C","Am"},{"Db","Bbm"},{"D","Bm"},{"Eb","Cm"},{"E","Dbm"},{"F","Dm"},
					{"Gb","Ebm"},{"G","Em"},{"Ab","Fm"},{"A", "Gbm"},{"Bb","Gm"},{"B", "Abm"}}
					
	self.transposition = {
		{SV:T("1 note"),  8, {}},
		{SV:T("2 notes"), 2, {"One note", "+1,+3", "+2,+5", "+2,+4", "+3,+5", "+3,+6", "-2,-5", "-3,-5"}},
		{SV:T("3 notes"), 1, {"+2,+5,+7", "+1,+3,+5", "+2,+3,+5", "-2,-5,-7"}},
		{SV:T("Octaves"), 4, {"+3,+5,+7", "+2,+7", "-7"; "-7,+7", "-3,-5,+7"}},
		{SV:T("Fixed"),  1, {"Fixed"}}
	}
	
	self.colors = self:getColors()
	self.scales = self:getScalesData(self.allScalesActive) -- Init activated scales or all	
	self.keyScaleChoice = self.keyNames
	self.controls = self:getControls()
	self:initializeControlsValues()
	self.pitchSelected = "0"
	
	-- SV:T("Selected") .. ": " .. pitchSelected
	self.controls.transpositionSelected.value:setValue(self.pitchSelectedLabel .. self.pitchSelected)
	
	self.applyButtonValue = SV:create("WidgetValue")
	self.statusTextValue = SV:create("WidgetValue")
	self.statusTextValue:setValue("")
	self.statusTextValue:setEnabled(false)
	
	self:setControlsCallback()
	self:setButtonApplyControlCallback()

	-- load combox data
	self:getComboLists()

	local infos = getClientInfo()
	if self.displayVersion then
		self:addTextPanel(SV:T("Version") .. ": " ..  infos.versionNumber 
			.. " - " .. SV:T("author") .. ": " .. infos.author)
	end
	self:addTextPanel(SV:T("Generate harmonies") .. "...")
	
	-- Double notes transposition list data
	self.transpositionDoubleNotesList = self.transposition[2][self.transpositionRefData]
	self.defaultKeyFoundMessage = SV:T("Select at least one group!") .. "\r"
	
	-- Register arrangement selection callback
	self:registerArrangementSelectionCallback()
	
    return self
end

-- Register arrangement selection callback
function NotesObject:registerArrangementSelectionCallback()
	
	-- Register selection callback to load parameters when selection changes
	SV:getArrangement():getSelection():registerSelectionCallback(function(selectionType, isSelected)
		
		self.groupsSelected = self:getSelectedGroups()
		
		if #self.groupsSelected > 0 then
			local keepUserScale = false
			local keysInfos = self:getGroupKeyScale(keepUserScale)
			if #keysInfos.keyScaleFound <= 0 then
				-- No comon key scale found
				self.controls.scaleKeyFound.value:setValue(keysInfos.scaleKeyResult)
			end
		end
	end)
	
	-- Register clear selection callback
	SV:getArrangement():getSelection():registerClearCallback(function(selectionType)
		-- No group selected in arrangement view
		self.controls.scaleKeyFound.value:setValue(self.defaultKeyFoundMessage)
	end)
end

-- Get scales data
function NotesObject:getScalesData(allscalesActive)
	local scales = {}
	
	local scalesReference = {
		-- KeyScale type, Intervals
		{name = SV:T("major"), 			val = {0,2,4,5,7,9,11,12},	active = true},
		{name = SV:T("natural minor"),	val = {0,2,3,5,7,8,10,12},	active = true},
		{name = SV:T("blues major"),	val = {0,2,3,4,7,9,12},		active = true},
		{name = SV:T("dorian"),			val = {0,2,3,5,7,9,10,12},	active = true},
		{name = SV:T("phrygian"),		val = {0,1,3,5,7,8,10,12},	active = true},
		{name = SV:T("melodic minor"),	val = {0,2,3,5,7,9,11,12},	active = false},
		{name = SV:T("harmonic minor"),	val = {0,2,3,5,7,8,11,12},	active = false},
		{name = SV:T("ionian"),			val = {0,2,4,5,7,9,11,12},	active = false},
		{name = SV:T("locrian"),		val	= {0,1,3,5,6,8,10,12},	active = false},
		{name = SV:T("lydian"),			val = {0,2,4,6,7,9,11,12},	active = false},
		{name = SV:T("mixolydian"),		val	= {0,2,4,5,7,9,10,12},	active = false},
		{name = SV:T("aeolian"),		val	= {0,2,3,5,7,8,10,12},	active = false},
		{name = SV:T("blues_minor"),	val	= {0,3,5,6,7,10,12},	active = false},
		{name = SV:T("japanese"),		val	= {0,1,5,7,8,12}, 		active = false},
		{name = SV:T("chinese"),		val	= {0,2,4,7,9,12}, 		active = false}, 
		{name = SV:T("chinese 2"),		val	= {0,4,6,7,11,12}, 		active = false},
		{name = SV:T("indian"),			val	= {0,1,3,4,7,8,10,12},	active = false},
		{name = SV:T("hungarian_major"),val = {0,3,4,6,7,9,10,12},	active = false}
	}
	
	-- loop to active scales
	for i = 1, #scalesReference do
		if allscalesActive or scalesReference[i].active then
			table.insert(scales, scalesReference[i])
		end
	end

	return scales
end

-- Display message box
function NotesObject:show(message)
	SV:showMessageBox(SV:T(SCRIPT_TITLE), message)
end

-- Get host informations
function NotesObject:getHostInformations()
	self.hostinfo = SV:getHostInfo()
	self.osType = self.hostinfo.osType  -- "macOS", "Linux", "Unknown", "Windows"
	self.osName = self.hostinfo.osName
	self.hostName = self.hostinfo.hostName
	self.languageCode = self.hostinfo.languageCode
	self.hostVersion = self.hostinfo.hostVersion
	self.hostVersionNumber = self.hostinfo.hostVersionNumber
end

-- Clear internal logs
function NotesObject:logsClear()
	self.logs = {}
end

-- Get object properties (debug only)
function NotesObject:getObjectProperties(obj, level)
	local result = ""
	local level = level or 0
	local maxLevel = 3
	level = level + 1
	
	for k, v in pairs(obj) do
		if obj[k] ~= nil then
			result = result .. "(" .. level .. ") " .. k .. "=" .. tostring(v) .. "\r"
			if type(v) == "table" then
				-- result = result .. ", size:" .. #v .. ": "
				if level < maxLevel then
					result = result .. self:getObjectProperties(v, level) .. "\r"
				else
					result = result .. "\r"
				end
			end
		end
	end
	return result
end
	
-- Get selected groups
function NotesObject:getSelectedGroups()	
	return SV:getArrangement():getSelection():getSelectedGroups()
end

-- Get current track
function NotesObject:getCurrentTrack()
	return SV:getMainEditor():getCurrentTrack()
end

-- Get timeAxis
function NotesObject:getTimeAxis()
	return self:getProject():getTimeAxis()
end

-- Get project
function NotesObject:getProject()
	return SV:getProject()
end

-- Get group key scale 
function NotesObject:getGroupKeyScale(keepUserScale)
	local scaleKeyResult = "" -- To display key scale found in TextArea
	local keyScaleFound = ""
	local keyFoundDisplay = ""
	local keyScaleFoundTrack = ""
	
	local trackName = ""
	if self:getCurrentTrack() ~= nil then
		trackName = self:getCurrentTrack():getName() .. " - "
	end
	scaleKeyResult = scaleKeyResult  .. trackName .. SV:T("Groups") .. " (" .. #self.groupsSelected .. ")" .. "\r"
	
	local keysInfosNew = self:getKeysInfos() -- in major key scale
	keyScaleFound = keysInfosNew.keyScaleFound
	keyFoundDisplay = keysInfosNew.keyFoundDisplay
	keyScaleFoundTrack = keysInfosNew.keyScaleFoundTrack
	
	if #keyScaleFound > 0 then
		self.keyScaleFound = self:getkeyScaleChoiceFromPos(self.posKeyInScaleForm)
		
		-- Keep user selection
		if not keepUserScale then
			self.controls.scaleKeyChoice.value:setValue(self.posKeyInScaleForm)
			self.controls.scaleKeyType.value:setValue(0) -- major default
		else
			self.keyScaleTypeFound  = self.controls.scaleKeyType.value:getValue() + 1
		end			

		self.keyScaleTypeTitleFound  	= self.scales[self.keyScaleTypeFound].name
		self.keyScaleTypeValuesFound	= self.scales[self.keyScaleTypeFound].val

		scaleKeyResult = scaleKeyResult  .. keyFoundDisplay .. "\r"
	else
		scaleKeyResult = scaleKeyResult  .. SV:T("No common scale key found!") .. "\r"
	end
	
	-- Display key scale found in TextArea
	self.controls.scaleKeyFound.value:setValue(scaleKeyResult)
	
	local keysInfos = { 
		keyScaleFound = keyScaleFound,
		keyFoundDisplay = keyFoundDisplay, 
		keyScaleFoundTrack = keyScaleFoundTrack,
		scaleKeyResult = scaleKeyResult
	}

	return keysInfos
end

-- Create a new track
function NotesObject:createTrack()
	local newTrack = SV:create("Track")
	newTrack:setDisplayColor(self.currentColor)
	
	self:getProject():addTrack(newTrack)
	return newTrack
end

-- Clone track from track reference
function NotesObject:cloneTrack()
	local newTrack = self.newTrackRef:clone()
	newTrack:setDisplayColor(self.currentColor)
	self:getProject():addTrack(newTrack)
	return newTrack
end

-- Get track list
function NotesObject:getTracksList()
	local list = {}
	local formatCount = "%3d"
	local iTracks = self:getProject():getNumTracks()
	
	for iTrack = 1, iTracks do
		local track = self:getProject():getTrack(iTrack)
		local numGroups = track:getNumGroups() - 1
		local format = formatCount .. " " .. SV:T("groups")
		if numGroups < 2 then
			format = formatCount .. " " .. SV:T("group")
		end
		table.insert(list, track:getName() .. " (" .. string.format(format, numGroups) .. ")" )
	end
	return list
end

-- Get scale from title
function NotesObject:getScaleFromTitle(scaleSearch)
	local scale = {}
	for iScale = 1, #self.scales do
		if scaleSearch == self.scales[iScale][1] then
			scale = self.scales[iScale]
		end
	end
	return scale
end

-- get scale Key Found in choice format
function NotesObject:getKeyScaleChoice(keyScaleFound)
	local choice = {}
	if string.find(keyScaleFound, self.SEP_KEYS) == nil then
		table.insert(choice, keyScaleFound)
	else
		choice = self:split(keyScaleFound, self.SEP_KEYS)
	end
	return choice
end

-- get relative minor scale Keys
function NotesObject:getRelativeMinorScaleKeys(keyScaleFound)
	local keys = self:getKeyScaleChoice(keyScaleFound)
	local relativeMinor = {}
	for iKey = 1, #keys do
		table.insert(relativeMinor, self:getKeyMajToMinor(keys[iKey]))
	end
	return relativeMinor
end

-- Get keys data infos
function NotesObject:getKeysInfos()
	local keyScaleFound = ""
	local keyFoundDisplay = ""
	local keyScaleFoundTrack = ""		

	-- Check groups selected
	if #self.groupsSelected > 0 then
		-- Group selected
		keyScaleFound = self:getScale(self.groupsSelected)
		
		-- Track notes to check
		keyScaleFoundTrack = self:getScaleTrack(self.groupsSelected)
		keyFoundDisplay = keyScaleFound
		
		self.isOnlyOneKeyFound = false
		self.isTrackKeyFound = false
		self.posKeyInScaleForm = 0
		if string.find(keyScaleFound, self.SEP_KEYS) == nil then
			self.isOnlyOneKeyFound = true
			keyScaleFoundMajor = self:split(keyScaleFound, "(")[1]
			self.posKeyInScaleForm = self:getKeyPosInKeynames(self.keyNames, keyScaleFoundMajor) -1
		end
		self.relativeMinorkeyScaleChoice = {}
		if keyScaleFound == "" then
			keyFoundDisplay = SV:T("No scale key found!")
		else
			-- self.keyScaleChoice = self:getKeyScaleChoice(keyScaleFound)
			self.relativeMinorScaleKeysChoice = self:getRelativeMinorScaleKeys(keyScaleFound)
			self.relativeMinorScalekeys = SV:T("Relative minor keys: ") 
				.. table.concat(self.relativeMinorScaleKeysChoice, "/")
			
			if #keyScaleFoundTrack > 0 then
				if keyScaleFound ~= keyScaleFoundTrack then
					keyFoundDisplay = keyScaleFound .. "\r" .. SV:T("Track: ") .. keyScaleFoundTrack
					keyScaleFoundMajor = self:split(keyScaleFoundTrack, "(")[1]
					self.isTrackKeyFound = true
					self.posKeyInScaleForm = self:getKeyPosInKeynames(self.keyNames, keyScaleFoundMajor) -1
				end
			end
		end
	end
	
	local keysInfos = { 
			keyScaleFound = keyScaleFound,
			keyFoundDisplay = keyFoundDisplay, 
			keyScaleFoundTrack = keyScaleFoundTrack
		}
	return keysInfos
end

-- Duplicate and transpose notes
function NotesObject:duplicateNotes(groupsSelected)
	local trackChoice = 0
	local pitchTarget = self.pitchSelected
	
	self.currentColor = self:getNewColor(self:getCurrentTrack())

	-- transposition[harmonyChoice (1 note, 2 note)][self.transpositionRefData][pitchPosInput = +2,+5, -3,-7 etc. + 1]
	local isFixed = (pitchTarget == "Fixed")
	local numGroups = 0
	
	local pitchTargets = self:split(pitchTarget, ",")
	if #pitchTargets > 1 then
		isMultipleTracks = true -- force for "build your own"
	end
	
	local posKeyInScale = self:getKeyPosInKeynames(self.keyNames, self.keyScaleFound) -1
	self.currentKeyNames = self:copyTable(self.keyNames)
	
	-- Rotate table content, start note to new key
	self:shiftTable(self.currentKeyNames, posKeyInScale)
	self.keysInScale = self:getKeysInScale(self.currentKeyNames, self.keyScaleFound)
	
	if string.len(self.keyScaleFound) == 0 then
		self:show(SV:T("Error: No scale key found!"))
		return -1
	end
	if posKeyInScale < 0 then
		self:show(SV:T("Error: Position into scale error!"))
		return posKeyInScale
	end
	local formatCount = "%3d"
	local iTracks = self:getProject():getNumTracks()
	
	if self.isTrackClone then
		self.newTrackRef = self:cloneTrackReference()
	end

	-- Only one track to add
	if not isMultipleTracks then
		local track = nil
		
		local newGroupRefs = self:groupLoop(groupsSelected, isFixed, pitchTarget, posKeyInScale)
		-- New track
		if #self.trackListChoice == trackChoice or trackChoice == 0 then
			if self.isTrackClone then
				track = self:cloneTrack()
			else
				track = self:createTrack()
			end
			local trackNumber = iTracks + 1
			track:setName(self.trackNameHarmony .. trackNumber .. " (" .. pitchTarget .. ")")
		else
			track = self:getProject():getTrack(trackChoice)
		end
		
		for iGroupRef = 1, #newGroupRefs do
			track:addGroupReference(newGroupRefs[iGroupRef])
			numGroups = numGroups + 1
		end
	else
		-- add multiple tracks
		for iTrack = 1, #pitchTargets do
			local track = nil
			
			pitchTarget = self:trim(pitchTargets[iTrack])
			isFixed = (pitchTarget == "Fixed")
			local newGroupRefs = self:groupLoop(groupsSelected, isFixed, pitchTarget, posKeyInScale)
			if self.isTrackClone then
				track = self:cloneTrack()
			else
				track = self:createTrack()
			end
			local trackNumber = iTrack + 1
			track:setName(self.trackNameHarmony .. trackNumber .. " (" .. pitchTarget .. ")")
			
			for iGroupRef = 1, #newGroupRefs do
				track:addGroupReference(newGroupRefs[iGroupRef])
				numGroups = numGroups + 1
			end
		end
	end
	
	if self.isTrackClone then
		self:deleteClonedTrack()
	end

	return numGroups
end

-- Clone track to keep current track voice
function NotesObject:cloneTrackReference()
	local newTrack = self:getCurrentTrack():clone()
	local iGroups = newTrack:getNumGroups()
	
	if iGroups > 1 then
		-- Delete groups
		while iGroups > 1 do
			local groupRef = newTrack:getGroupReference(iGroups)
			local index = groupRef:getIndexInParent()
			if groupRef ~= nil and not groupRef:isMain() then
				newTrack:removeGroupReference(index)
				iGroups = newTrack:getNumGroups()
			end
		end
	end
	
	newTrack:setName("Track voice ref")
	self:getProject():addTrack(newTrack)

	return newTrack
end

-- Delete track reference
function NotesObject:deleteClonedTrack()
	local result = false
	if self.newTrackRef ~= nil then
		local index = self.newTrackRef:getIndexInParent()
		self:getProject():removeTrack(index)
		result = true
	end
	return result
end

-- Loop into groups to duplicate & transpose notes
function NotesObject:groupLoop(groupsSelected, isFixed, pitchTarget, posKeyInScale)
	local newGroupRefs = {}

	for _, refGroup in pairs(groupsSelected) do
		-- local groupName = refGroup:getTarget():getName()
		local noteGroup = refGroup:getTarget()
		local groupRefTimeoffset = refGroup:getTimeOffset()

		-- Clone source group
		local newNoteGroup = noteGroup:clone()
		local selectedNotes = newNoteGroup:getNumNotes()
		
		if selectedNotes >= 0 then
		
			-- Duplicate transposed notes into a new track to create
			-- Tranpose notes
			local firstNote = newNoteGroup:getNote(1)
			local lastNote = newNoteGroup:getNote(selectedNotes)
			local firstNotePitch = firstNote:getPitch()
			for iNote = 1, selectedNotes do
				local note = newNoteGroup:getNote(iNote)
				local notePitch = self:getNewPitch(isFixed, firstNotePitch, 
					note:getPitch(), tonumber(pitchTarget), posKeyInScale)
				note:setPitch(notePitch)
			end
			self:getProject():addNoteGroup(newNoteGroup)
			
			-- Add group reference to project new track
			local newGrouptRef = SV:create("NoteGroupReference", newNoteGroup)
			
			-- Adjust time offset
			newGrouptRef:setTimeOffset(groupRefTimeoffset)
			
			-- Adjust time range & voice attributes
			newGrouptRef:setTimeRange(refGroup:getOnset(), refGroup:getDuration())
			newGrouptRef:setVoice(refGroup:getVoice())
			
			if #self.languageOverride > 0 then
				-- Update notes language
				self:updateNotesLanguageOverride(newNoteGroup)
			end
						
			-- AI retakes
			if self.retakes then
				-- Update AI retakes
				self:updateAIRetakes(newNoteGroup)
			end
			
			table.insert(newGroupRefs, newGrouptRef)
		end
	end
	
	return newGroupRefs
end

-- Update notes language override
function NotesObject:updateNotesLanguageOverride(newNoteGroup)
	
	for iNote = 1, newNoteGroup:getNumNotes() do
		local note = newNoteGroup:getNote(iNote)
		note:setLanguageOverride(self.languageOverride)
	end
end

-- Update AI Retakes for new group note harmony
function NotesObject:updateAIRetakes(newNoteGroup)
	
	for iNote = 1, newNoteGroup:getNumNotes() do
		local note = newNoteGroup:getNote(iNote)
		local retakeListNote = note:getRetakes()
			if retakeListNote ~= nil then
				-- Generate new AI retakes
				local takeId = retakeListNote:generateTake(self.newDurationRetakes, self.newPitchRetakes, self.newTimbreRetakes)
				retakeListNote:setActiveTake(takeId)
			end
	end
end

-- Trim string
function NotesObject:trim(s)
  return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
end

-- Scale tools
-- Pitch note is in scale
function NotesObject:isInScale(pitch, scale)
	local usekey = self.keyScaleTypeValuesMajor
	local inScale = false
	for key = 1, #usekey do
		if pitch % 12 == (usekey[key] + scale) % 12 then
			inScale = true
			break
		end
	end
	return inScale
end

-- Key note is in scale
function NotesObject:isKeyInScale(keyPos)
	local usekey = self.keyScaleTypeValuesMajor
	local inScale = false
	for key = 1, #usekey do
		if usekey[key] == keyPos then
			inScale = true
			break
		end
	end
	return inScale
end

-- GetScale in current track
function NotesObject:getScaleTrack(groupsSelected)
	return self:getScale(groupsSelected,  "track")
end

-- GetScale
function NotesObject:getScale(groupsSelected, paramTrack)
	local groupOrTrackNotes = "None"
	local scaleFound = ""
	local notes = {}
	local sep = ""
	local trackinfos = ""
	
	if paramTrack == "track" then
		-- Use current track
		groupOrTrackNotes = "Track"
		-- Loop through groups in track
		local numGroups = self:getCurrentTrack():getNumGroups()
		local refGroupTrack = nil
		trackinfos = SV:T("Groups") .. " (" .. numGroups .. ")"
		for grp = 1, numGroups do
			refGroupTrack = self:getCurrentTrack():getGroupReference(grp)
			self:addNotes(notes, refGroupTrack)
		end
	else
		-- Groups selected
		if #groupsSelected > 0 then
			groupOrTrackNotes = SV:T("Groups") .. " (" .. #groupsSelected .. ")"
			for _, group in pairs(groupsSelected) do
				self:addNotes(notes, group)
			end
		else
			self:show(SV:T("No group selected!"))
		end
	end
	
	-- loop each scales
	for key = 1, #self.keyNames do
		local isInScale = false
		local posKeyInScale = key - 1
		
		-- Loop on pitch notes
		isInScale = self:loopNotes(notes, posKeyInScale, self.keyNames, key)
		if isInScale then
			-- scale found
			scaleFound = scaleFound .. sep .. self.keyNames[key] 
				.. "(" .. self:getKeyMajToMinor(self.keyNames[key]) .. ")"
			sep = self.SEP_KEYS
		end
	end		
	return scaleFound
end

-- Append notes from group
function NotesObject:addNotes(notes, refGroup)
	-- Check group type
	if not refGroup:isInstrumental() then
		local notesGroup = refGroup:getTarget()
		-- Store group notes
		for note = 1, notesGroup:getNumNotes() do
			local pitchNote = notesGroup:getNote(note):getPitch()
			if pitchNote ~= nil then
				table.insert(notes, pitchNote)
			end
		end
	end
end

-- Get new pitch in key scale
function NotesObject:getNewPitch(isFixed, firstNotePitch, notePitch, pitchTarget, posKeyInScale)
	if isFixed then 
		-- Fix all notes from the first note found
		notePitch = firstNotePitch
	else
		notePitch = self:getNextKeyInScale(self.keyScaleFound, notePitch, pitchTarget)
	end
	return notePitch
end

-- Get next valid key in scale
function NotesObject:getNextKeyInScale(keyScaleFound, notePitch, pitchTarget)
	local octave = 0

	-- Octave -1
	if pitchTarget < 0 then
		pitchTarget = 7 + pitchTarget
		octave = -12
	end
	
	local noteKey = self:getKeyFromPitch(notePitch)
	local posKeyInScaleKey = self:getKeyPosInKeynames(self.keysInScale, noteKey)
	local posTarget = ((posKeyInScaleKey + pitchTarget - 1) % 7) + 1
	local nextKey = self.keysInScale[posTarget]
	
	local gapDegree = self:getShiftDegrees(pitchTarget, posKeyInScaleKey)
	local notePitchNew = notePitch + gapDegree + octave
	
	return notePitchNew
end

-- Get shifted degrees
function NotesObject:getShiftDegrees(pitchTarget, posKeyInScaleKey)
	local shift = 0
	if pitchTarget > 0 then

		for key = 1, pitchTarget do
			
			-- Add all gaps to get shifting note
			local dec = (posKeyInScaleKey + key - 2) % 7 + 1
			-- {0,2,4,5,7,9,11} => {2, 2, 1, 2, 2, 2, 1}
			--                        {2, 1, 2, 2, 1, 2, 2} "Natural Minor" 
			local keyScaleTypeGaps = self:getKeyScaleTypeToGap(self.keyScaleTypeValuesFound)
			shift = shift + keyScaleTypeGaps[dec]
		end
	end
	return shift
end

-- Get key scale type to gap values
function NotesObject:getKeyScaleTypeToGap(keyScaleTypeValuesFound)
	-- {0,2,4,5,7,9,11} => {2, 2, 1, 2, 2, 2, 1}
	local keyScaleGaps = {}
		for iKey = 1, #keyScaleTypeValuesFound -1 do
			table.insert(keyScaleGaps, keyScaleTypeValuesFound[iKey + 1] - keyScaleTypeValuesFound[iKey])
		end
	return keyScaleGaps
end

-- Get key pitch
function NotesObject:getKeyFromPitch(notePitch)
	local pitchPos = notePitch % 12
	return self.keyNames[pitchPos + 1]
end

-- loop for each notes
function NotesObject:loopNotes(notes, posKeyInScale, keyNames, key)
	local isInScale = false
	-- loop all notes
	for note = 1, #notes do
		local notePitch = notes[note]
		if notePitch ~= nil then
			isInScale = self:isInScale(notePitch, posKeyInScale)
			if not isInScale then
				break
			end
		end
	end
	return isInScale
end

-- Get key position in Keynames
function NotesObject:getKeyPosInKeynames(keyNames, keyfound)
	local posKeyInScale = -1
	-- loop each scales
	for key = 1, #keyNames do
		if keyfound == keyNames[key] then
			posKeyInScale = key
			break
		end
	end
	return posKeyInScale
end

-- Get key scale found from position self.keyScaleChoice
function NotesObject:getkeyScaleChoiceFromPos(scaleKeyPosInput)
	local keyScaleFound = ""
	for iPos = 1, #self.keyScaleChoice do
		if scaleKeyPosInput == iPos -1 then
			keyScaleFound = self.keyScaleChoice[iPos]
		end
	end
	return keyScaleFound
end

-- Get keys in scale
function NotesObject:getKeysInScale(currentKeyNames, keyScaleFound)
	local keysInScale = {}
	for key = 1, #currentKeyNames do
		if self:isKeyInScale(key-1) then
			table.insert(keysInScale, currentKeyNames[key])
		end
	end
	return keysInScale
end

-- Key tools
-- Get Key from minor to major
function NotesObject:getKeyMinToMaj(key)
	local arrKeys = self.relativeKeys
	
	for iMaj, kMin in pairs(arrKeys) do
		if key == kMin[2] then
			keyResult = kMin[1]
		end
	end	
	return keyResult
end

-- Get Key from major to minor
function NotesObject:getKeyMajToMinor(key)
	local arrKeys = self.relativeKeys
	
	for iMaj, kMin in pairs(arrKeys) do
		if key == kMin[1] then
			keyResult = kMin[2]
		end
	end	
	return keyResult
end

-- Get pitch action from position
function NotesObject:getPitchActionFromPos(pos, harmonyChoice)
	return self.transposition[harmonyChoice][self.transpositionRefData][pos + 1]
end

-- Split string by sep char
function NotesObject:split(str, sep)
	local result = {}
	local regex = ("([^%s]+)"):format(sep)
	for each in str:gmatch(regex) do
		table.insert(result, each)
	end
	return result
end

-- Rotate table content
function NotesObject:shiftTable(tInput, num)
	for iPos = 1, math.abs ( num ) do
		if num < 0 then
			table.insert ( tInput, 1, table.remove ( tInput ) )
		else
			table.insert ( tInput, table.remove ( tInput, 1 ) )
		end
	end
end

-- Duplicate table
function NotesObject:copyTable(tInput)
	local tOutput = {}
	for k, v in pairs(tInput) do
		table.insert(tOutput, k, v)
	end
	return tOutput
end

-- Add log into self.logs
function NotesObject:addLogs(message)
	table.insert(self.logs, message)
	self:addTextPanel(message)
end

-- Display logs into panel
function NotesObject:addLogsInPanel()
	for i = 1, #self.logs do
		self:addTextPanel(self.logs[i])
	end
end

-- Display message box in panel
function NotesObject:addTextPanel(message)
	local old = self.statusTextValue:getValue()
	local sepLine = "\r"
	if #old > 0 then
		message = old .. sepLine .. message
	end
	self.statusTextValue:setValue(message)
end

-- Clear display message in panel
function NotesObject:clearTextPanel()
	self.statusTextValue:setValue("")
end

-- Store error message
function NotesObject:error(message)
	table.insert(self.errorMessages, message)
end

-- Get controls panel
function NotesObject:getControls()
	-- TextArea: Key found 						scaleKeys
	-- ComboBox: Select a key scale				scaleKeyChoice
	-- ComboBox: Key scale type					scaleKeyType
	-- Slider:   Pitch transposition			pitch
	-- ComboBox: Harmony type					harmonyChoice
	-- CheckBox: use current track as source	isTrackClone
	-- button:   apply							applyButtonValue
	-- TextArea: status text 						statusTextValue
	
	local controls = {
		scaleKeyFound = {						-- TextArea: Key found
			value = SV:create("WidgetValue"),
			defaultValue = "",
			paramKey = "scaleKeyFound"
		},
		scaleKeyChoice = {						-- ComboBox: Select a key scale
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- C
			paramKey = "scaleKeyChoice"
		},
		scaleKeyType = {						-- ComboBox: Key scale type
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- major
			paramKey = "scaleKeyType"
		},
		harmonyChoice = {						-- ComboBox: Harmony type
			value = SV:create("WidgetValue"),
			defaultValue = 0,
			paramKey = "harmonyChoice"
		},
		trackChoice = {							-- ComboBox: Destination track
			value = SV:create("WidgetValue"),
			defaultValue = 0, 
			paramKey = "trackChoice"
		},
		pitch = {								-- ComboBox: Pitch to select
			value = SV:create("WidgetValue"),
			defaultValue = 0, 
			paramKey = "pitch"
		},
		transpositionSelected = {				-- TextArea: transposition selected
			value = SV:create("WidgetValue"),
			defaultValue = 0, 
			paramKey = "transpositionSelected"
		},
		isTrackClone = {						-- CheckBox: Use current track as source
			value = SV:create("WidgetValue"),
			defaultValue = false,
			paramKey = "isTrackClone"
		}
	}
	return controls
end

-- Initialize widget values
function NotesObject:initializeControlsValues()
	-- Initialize widget values
	for key, control in pairs(self.controls) do
		control.value:setValue(control.defaultValue)
	end
end

-- Set controls callback (TODO)
function NotesObject:setControlsCallback()
	for key, control in pairs(self.controls) do
		control.value:setValueChangeCallback(function()
				-- self:addLogsInPanel()
								
				if control.paramKey == "pitch" then
					self.pitchSelectedType = control.paramKey
					self.pitchSelected = string.format("%i", self.controls.pitch.value:getValue())
					
					-- Display SV:T("Selected") .. ": " .. pitchSelected
					self.controls.transpositionSelected.value:setValue(self.pitchSelectedLabel 
						.. string.format("%i", self.pitchSelected))
					
					-- Reset harmonyChoice value because user select "pitch" only "one note" for harmonyChoice
					self.controls.harmonyChoice.value:setValue(0)
				end
				
				if control.paramKey == "harmonyChoice" then
					self.pitchSelectedType = control.paramKey
					local transpositionSelected = self.controls.harmonyChoice.value:getValue() + 1
					if transpositionSelected == 1 then
						self.pitchSelected = 0
					else
						self.pitchSelected = self.transpositionDoubleNotesList[transpositionSelected]
					end
					
					-- Display SV:T("Selected") .. ": " .. pitchSelected
					self.controls.transpositionSelected.value:setValue(self.pitchSelectedLabel
						.. self.pitchSelected)
					
					-- Reset simple transposition value because user select "harmonyChoice" double notes
					self.controls.pitch.value:setValue(0)
				end
			end
		)
	end
end

-- Set button apply control callback
function NotesObject:setButtonApplyControlCallback()

	-- Button create harmony
	self.applyButtonValue:setValueChangeCallback(function()
			self:getProject():newUndoRecord()

			self.groupsSelected = self:getSelectedGroups()
			
			if #self.groupsSelected > 0 then
				self.isTrackClone = self.controls.isTrackClone.value:getValue()
				
				local keepUserScale = true -- Keep user key scale selection
				local keysInfos = self:getGroupKeyScale(keepUserScale)
				if #keysInfos.keyScaleFound > 0 then		
					-- Duplicate note groups & create tracks
					local numGroups = self:duplicateNotes(self.groupsSelected)
				else
					-- No key scale found
					self.controls.scaleKeyFound.value:setValue(keysInfos.scaleKeyResult)
				end
			else
				-- No group selected
				self.controls.scaleKeyFound.value:setValue(self.defaultKeyFoundMessage)
				self:show(self.defaultKeyFoundMessage)
			end
		end
	)
end
	
-- Get combo box data
function NotesObject:getComboLists()
	self.scalesList = {}
	
	-- scales list
	for key, v in ipairs(self.scales) do
		table.insert(self.scalesList, self.scales[key].name)
	end
end

-- Display error messages
function NotesObject:displayErrors()
	local result = ""
	if #self.errorMessages > 0 then
		for _, m in pairs(self.errorMessages) do
			result = result .. m .. "\r"
		end
	end
	return result
end

-- Get new color
function NotesObject:getNewColor(track)
	if self.currentColorPos == 0 then 
		self.currentColorPos = self:getCurrentColorPos(track)
	end
	self.currentColorPos = self.currentColorPos + 1
	if self.currentColorPos > #self.colors then
		self.currentColorPos = 1
	end
	return self.colors[self.currentColorPos].val
end

-- Get current color position
function NotesObject:getCurrentColorPos(track)
	local newPos = 1
	for i, color in ipairs(self.colors) do
		if color.val == track:getDisplayColor() then
			newPos = i
			break
		end
	end	
	return newPos
end

-- Get colors
function NotesObject:getColors()
	local colors = {}
	table.insert(colors, {val = "ffd14f5b", name = "red"})
	table.insert(colors, {val = "ffc27455", name = "orange"})
	table.insert(colors, {val = "ffc27455", name = "ocher"})
	table.insert(colors, {val = "ffd6bc43", name = "yellow"})
	table.insert(colors, {val = "ff7db235", name = "green"})
	table.insert(colors, {val = "ff3bb26c", name = "greenish"})
	table.insert(colors, {val = "ff3eb2a8", name = "blue-sky"})
	table.insert(colors, {val = "ff4794cb", name = "blue"})
	table.insert(colors, {val = "ff5478c7", name = "turquoise"})
	table.insert(colors, {val = "ff6959d4", name = "purple"})
	table.insert(colors, {val = "ffb853b3", name = "pink"})
	return colors
end


-- Create user input form
function NotesObject:getSectionContainer()
	local scaleKeyType = {}
	local pitchMinValue = -7
	local pitchMaxValue = 7
	local pitchInterval = 1
	local defaultKeyPos = 0

	if self.isOnlyOneKeyFound then
		defaultKeyPos = self.posKeyInScaleForm
	else
		if self.isTrackKeyFound then
			defaultKeyPos = self.posKeyInScaleForm
		end
	end
	
	-- TextArea: Key found 						scaleKeys
	-- ComboBox: Select a key scale				scaleKeyChoice
	-- ComboBox: Key scale type					scaleKeyType
	-- Slider:   Pitch transposition			pitch
	-- ComboBox: Harmony type					harmonyChoice
	-- CheckBox: use current track as source	isTrackClone
	-- button:   apply							applyButtonValue
	-- TextArea: status text 						statusTextValue

	self.controls.scaleKeyFound.value:setValue(self.defaultKeyFoundMessage)

	local scaleKeyFound =  
		{
			type = "Container",
			columns = {
				{
					type = "TextArea",
					value = self.controls.scaleKeyFound.value,
					height = 60,
					width = 1.0,
					readOnly = true
				}
			}
		}

	local scaleKeyChoice = 
		{
			type = "Container",
			columns = {
				{
					type = "ComboBox",
					text = SV:T("Select a key scale"),
					value = self.controls.scaleKeyChoice.value,
					choices = self.keyScaleChoice,
					width = 1.0
				}
			}
		}

	local scaleKeyType =   
		{
			type = "Container",
			columns = {
				{
					type = "ComboBox",
					text = SV:T("Key scale type"),
					value = self.controls.scaleKeyType.value,
					choices = self.scalesList,
					width = 1.0
				}
			}
		}

	self.controls.isTrackClone.value:setValue(self.isCurrentVoiceTrack)
	local trackClone = 
		{
			type = "Container",
			columns = {
				{
				type = "CheckBox",
				text = SV:T("Get current voice for new tracks"),
				value = self.controls.isTrackClone.value,
				width = 1.0
				}
			}
		}

	self.controls.isTrackClone.value:setValue(self.isCurrentVoiceTrack)
		
	local transpositionSelected =  
		{
			type = "Container",
			columns = {
				{
					type = "TextArea",
					value = self.controls.transpositionSelected.value,
					height = 20,
					width = 1.0,
					readOnly = false
				}
			}
		}

	local harmonyChoice = 
		{
			type = "Container",
			columns = {
				{
					type = "ComboBox",
					text = SV:T("Harmony type"),
					value = self.controls.harmonyChoice.value,
					choices = self.transpositionDoubleNotesList,
					width = 1.0
				}
			}
		}
		
	local pitchChoice = 
		{
			type = "Container",
			columns = {
				{
					type = "Slider",
					text = SV:T("Transpose (-7 to +7)"),
					format = "%3.0f pitch",
					minValue = pitchMinValue, 
					maxValue = pitchMaxValue, 
					interval = pitchInterval,
					value = self.controls.pitch.value,
					width = 0.5
				}
			}
		}
	
	-- Define CheckBox & button & textarea
	local section = {
		title = SV:T(SCRIPT_TITLE),
		rows = {
			scaleKeyFound,
			scaleKeyChoice,
			scaleKeyType,
			pitchChoice,
			harmonyChoice,
			transpositionSelected,
			trackClone,
			{
				type = "Container",
				columns = {
					{
						type = "Button",
						text = SV:T("Apply"),
						width = 1.0,
						value = self.applyButtonValue
					}
				}
			},
			{
				type = "Container",
				columns = {
					{
						type = "TextArea",
						value = self.statusTextValue,
						height = 40,
						width = 1.0,
						readOnly = true
					}
				}
			}
		}
	}
	return section
end

-- Get panel section state
function NotesObject:getPanelSectionState()
	self:logsClear()
	self.applyButtonValue:setEnabled(true)
	
	local section = self:getSectionContainer()

	local errors = self:displayErrors()
	if #errors > 0 then
		self:addTextPanel(errors)
	end
	
	return section
end

-- Get panel section state called by Synthesizer V internal system
function getSidePanelSectionState()

	-- Initialize main internal object
	local notesObject = NotesObject:new()
	local section = notesObject:getPanelSectionState()
	return section
end
