local SCRIPT_TITLE = '..Harmonies'

--[[

lua file name: HarmonyPanel.lua

Copy selected groups to a new track and transpose all included notes
Add only one track or multiple tracks depending on user selection.

1/ Transpose all notes in current key scale -7 to +7 (C, D.. to B)
2/ Display current key scale found in selected group(s)
3/ Use current track to duplicate new track (to keep track voice)
4/ Generate AI retakes for each new group harmony
5/ Panel display introduced with Synthesizer V version 2.1.2

Update: Minor updates
		4 - Add negative harmony option
		5 - Major update: Prior use user scale choice (ComboBox) than scale found (or not)
			and update outer scale checkbox is added
		6 - Add check box: major scale only detection and detection property in scalesReference
		
Notice: Works only with script panel 
		introduced with Synthesizer V version >= 2.1.2

2025 - JF AVILES
--]]

function getClientInfo()
	return {
		name = SV:T(SCRIPT_TITLE),
		-- category = "_JFA_Panels",
		author = "JFAVILES",
		versionNumber = 6,
		minVersion = 131329,
		type = "SidePanelSection"
	}
end

-- Generated by JFA TranslateScripts.lua
function getTranslations(langCode)
	return getArrayLanguageStrings()[langCode]
end

-- Generated by JFA TranslateScripts.lua
function getArrayLanguageStrings()
	return {
		["en-us"] = {
			{"Track scale test", "Track scale test"},
			{"1 note", "1 note"},
			{"Selected", "Selected"},
			{"Major", "Major"},
			{"Track H", "Track H"},
			{"2 notes", "2 notes"},
			{"3 notes", "3 notes"},
			{"Octaves", "Octaves"},
			{"Fixed", "Fixed"},
			{"Negative", "Negative"},
			{"Version", "Version"},
			{"author", "author"},
			{"minEditorVersion", "minEditorVersion"},
			{"Generate harmonies", "Generate harmonies"},
			{"Select at least one group!", "Select at least one group!"},
			{"major", "major"},
			{"natural minor", "natural minor"},
			{"blues major", "blues major"},
			{"dorian", "dorian"},
			{"phrygian", "phrygian"},
			{"melodic minor", "melodic minor"},
			{"harmonic minor", "harmonic minor"},
			{"ionian", "ionian"},
			{"locrian", "locrian"},
			{"lydian", "lydian"},
			{"mixolydian", "mixolydian"},
			{"aeolian", "aeolian"},
			{"blues_minor", "blues_minor"},
			{"japanese", "japanese"},
			{"chinese", "chinese"},
			{"chinese 2", "chinese 2"},
			{"indian", "indian"},
			{"hungarian_major", "hungarian_major"},
			{"Groups", "Groups"},
			{"No common scale key found!", "No common scale key found!"},
			{"groups", "groups"},
			{"group", "group"},
			{"No scale key found!", "No scale key found!"},
			{"Track: ", "Track: "},
			{"Error: No scale key found!", "Error: No scale key found!"},
			{"Error: Position into scale error!", "Error: Position into scale error!"},
			{"No group selected!", "No group selected!"},
			{"Major scales only detection", "Major scales only detection"},
			{"Select a key scale", "Select a key scale"},
			{"Key scale type", "Key scale type"},
			{"Get current voice for new tracks", "Get current voice for new tracks"},
			{"Update notes outer scale", "Update notes outer scale"},
			{"Harmony type", "Harmony type"},
			{"Transpose (-7 to +7)", "Transpose (-7 to +7)"},
			{"Generate group", "Generate group"},
			{"Detection: Select a group", "Detection: Select a group"},
			{"Action: Select a scale and type", "Action: Select a scale and type"},
			{"Apply", "Apply"},
		},
	}
end

-- Define a class  "NotesObject"
NotesObject = {
	hostinfo = nil,
	osType = "",
	osName = "",
	hostName = "",
	languageCode = "", 
	hostVersion = "",
	hostVersionNumber = 0,	
	displayVersion = true,	-- display version
	displayAuthor = false,	-- display author
	allScalesActive = false,			-- true to list all scales
	isDetectionMajorScaleOnly = true, 	-- detection limited to major scale
	isUpdateNotesOuterScale = true, 	-- Update notes outer scale
	trackTestActive = false,			-- Add track button to generate samples notes in scale
	trackTest = nil,					-- track to test harmonies
	trackTestTitle = SV:T("Track scale test"), -- track to test harmonies
    scales = {},
	errorMessages = {},
	keyNames = {},					-- {"C", "Db", "D", ...
	currentKeyNames = {},			-- {"C", "Db", "D", ...
	posKeyInScale = 0,
	keysInScale = {},
	relativeKeys = {},				-- {{"C","Am"},{"Db","Bbm"},{"D","Bm"},
	transposition = {},
	transpositionRefLabel = 1,		-- {Label = SV:T("1 note"), Position = 8, RefData = {"+7", "+6", "+5",...
	transpositionRefPosition = 2,	-- Position = 8,
	transpositionRefData = 3,		-- RefData = {"+7", "+6", "+5",...
	pitchSelected = "",				-- Selected: 0 or 1 or +3, +5 etc.
	pitchSelectedLabel = SV:T("Selected") .. ": ",
	pitchSelectedType = "pitch",
	isOnlyOneKeyFound = false,
	isTrackKeyFound = false,
	posKeyInScaleForm = 0,
	SEP_KEYS = "/",
	keyScaleChoice = {},
	-- relativeMinorScalekeysChoice = {},
	-- relativeMinorScalekeys = "",
	keyScaleSelected = "",
	keyScaleTypeSelected  = 1,		
	keyScaleTypeTitleSelected  = "",
	keyScaleTypeValuesSelected = {0,2,4,5,7,9,11}, -- default major
	trackNameHarmony = "",
	isTrackClone = false,
	isFixed = false,
	isNegativeHarmony = false,
	firstNegativeNote = 0,
	newTrackRef = nil,
	tracks = {},
	trackListChoice = {},
	outputLevelDefaultValue = 0,
	isCurrentVoiceTrack = true,
	languageOverride = "", 		-- Language override (Empty string => disabled)
	retakes = true, 			-- Enable AI retakes
	newDurationRetakes = true,	-- AI retakes
	newPitchRetakes = true,		-- AI retakes
	newTimbreRetakes = true,	-- AI retakes
	defaultKeyFoundMessage = "",
	groupsSelected = {},
	scalesList = {},
	controls = {}, -- controls panel
	applyButtonValue = nil,				-- button
	generateGroupButtonValue = nil,		-- button
	statusTextValue = nil,				-- text panel
	colors = {},
	currentColorPos = 0,
	currentColor = "",
	infosToDisplay = "",
	harmonyList = {},
	displayMultiplePitchChoice = false,
	transpositionSelected = 0,
	debug = false,
	resultDebug = "",
	logs = {}	
}

-- Constructor method for the NotesObject class
function NotesObject:new()
    local notesObject = {}
    setmetatable(notesObject, self)
    self.__index = self
	
	self:getHostInformations()
	self.keyScaleTypeSelected  = 0 -- SV:T("Major")
	self.trackNameHarmony = SV:T("Track H")
	
	self.keyNames = {"C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"}
	self.currentKeyNames = {"C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"}
	self.relativeKeys = {{"C","Am"},{"Db","Bbm"},{"D","Bm"},{"Eb","Cm"},{"E","Dbm"},{"F","Dm"},
					{"Gb","Ebm"},{"G","Em"},{"Ab","Fm"},{"A", "Gbm"},{"Bb","Gm"},{"B", "Abm"}}
					
	self.transposition = {
		{SV:T("1 note"),  8, {}},
		{SV:T("2 notes"), 2, {"+1,+3", "+2,+5", "+2,+4", "+3,+5", "+3,+6", "-2,-5", "-3,-5"}},
		{SV:T("3 notes"), 1, {"+2,+5,+7", "+1,+3,+5", "+2,+3,+5", "-2,-5,-7"}},
		{SV:T("Octaves"), 4, {"+3,+5,+7", "+2,+7", "-7"; "-7,+7", "-3,-5,+7"}},
		{SV:T("Fixed"),  1, {"Fixed"}},
		{SV:T("Negative"),  1, {"Negative"}}
	}
	
	self.colors = self:getColors()
	self.scales = self:getScalesData(self.allScalesActive) -- Init activated scales or all	
	self.keyScaleChoice = self.keyNames
	
	self.controls = self:getControls()
	self:initializeControlsValues()
	
	self.pitchSelected = "0"
	self.harmonyList = self:getHarmonyList()
	
	-- SV:T("Selected") .. ": " .. pitchSelected
	self.controls.transpositionSelected.value:setValue(self.pitchSelectedLabel .. self.pitchSelected)
	self.transpositionSelected = 0
	
	self.applyButtonValue = SV:create("WidgetValue")
	self.generateGroupButtonValue = SV:create("WidgetValue")
	self.statusTextValue = SV:create("WidgetValue")
	self.statusTextValue:setValue("")
	self.statusTextValue:setEnabled(false)
	
	self:setControlsCallback()
	self:setButtonApplyControlCallback()
	self:setButtonGenerateGroupControlCallback()

	-- load combox data
	self:getComboLists()

	local infos = getClientInfo()

	self.infosToDisplay = ""
	if self.displayVersion then
		self.infosToDisplay = self.infosToDisplay .. SV:T("Version") .. ": " ..  infos.versionNumber
		if self.displayAuthor then
			self.infosToDisplay = self.infosToDisplay .. " - " .. SV:T("author") .. ": " .. infos.author
		end
	end
	-- self.infosToDisplay = self.infosToDisplay .. SV:T("minEditorVersion") .. ": " ..  infos.minEditorVersion
	self:addTextPanel(self.infosToDisplay)
	self:addTextPanel(SV:T("Generate harmonies") .. "...")
	
	self.defaultKeyFoundMessage = SV:T("Select at least one group!") .. "\r"
	
	-- Register arrangement selection callback
	self:registerArrangementSelectionCallback()
	
    return self
end

-- Register arrangement selection callback
function NotesObject:registerArrangementSelectionCallback()
	
	-- Register selection callback to load parameters when selection changes
	SV:getArrangement():getSelection():registerSelectionCallback(function(selectionType, isSelected)
		self.groupsSelected = self:getSelectedGroups()
		
		if #self.groupsSelected > 0 then
			local keysInfos = self:getGroupKeyScale()
			
			if #keysInfos.keyScaleFound <= 0 then
				-- No comon key scale found
				self.controls.scaleKeyFound.value:setValue(keysInfos.scaleKeyResult)
			end
		end
	end)
	
	-- Register clear selection callback
	SV:getArrangement():getSelection():registerClearCallback(function(selectionType)
		-- No group selected in arrangement view
		self.controls.scaleKeyFound.value:setValue(self.defaultKeyFoundMessage)
	end)
end

-- Get scales data
function NotesObject:getScalesData(allscalesActive)
	local scales = {}
	
	local scalesReference = {
		-- KeyScale type, Intervals
		{name = SV:T("major"), 			val = {0,2,4,5,7,9,11},	active = true , detection = true},
		{name = SV:T("natural minor"),	val = {0,2,3,5,7,8,10},	active = true , detection = true},
		{name = SV:T("blues major"),	val = {0,2,3,4,7,9},	active = true , detection = true},
		{name = SV:T("dorian"),			val = {0,2,3,5,7,9,10},	active = true , detection = true},
		{name = SV:T("phrygian"),		val = {0,1,3,5,7,8,10},	active = true , detection = true},
		{name = SV:T("melodic minor"),	val = {0,2,3,5,7,9,11},	active = false, detection = false},
		{name = SV:T("harmonic minor"),	val = {0,2,3,5,7,8,11},	active = false, detection = false},
		{name = SV:T("ionian"),			val = {0,2,4,5,7,9,11},	active = false, detection = false},
		{name = SV:T("locrian"),		val	= {0,1,3,5,6,8,10},	active = false, detection = false},
		{name = SV:T("lydian"),			val = {0,2,4,6,7,9,11},	active = false, detection = false},
		{name = SV:T("mixolydian"),		val	= {0,2,4,5,7,9,10},	active = false, detection = false},
		{name = SV:T("aeolian"),		val	= {0,2,3,5,7,8,10},	active = false, detection = false},
		{name = SV:T("blues_minor"),	val	= {0,3,5,6,7,10},	active = false, detection = false},
		{name = SV:T("japanese"),		val	= {0,1,5,7,8}, 		active = false, detection = false},
		{name = SV:T("chinese"),		val	= {0,2,4,7,9}, 		active = false, detection = false}, 
		{name = SV:T("chinese 2"),		val	= {0,4,6,7,11}, 	active = false, detection = false},
		{name = SV:T("indian"),			val	= {0,1,3,4,7,8,10},	active = false, detection = false},
		{name = SV:T("hungarian_major"),val = {0,3,4,6,7,9,10},	active = false, detection = false}
	}
	
	-- loop to active scales
	for i = 1, #scalesReference do
		if allscalesActive or scalesReference[i].active then
			table.insert(scales, scalesReference[i])
		end
	end

	return scales
end

-- Display message box
function NotesObject:show(message)
	SV:showMessageBox(SV:T(SCRIPT_TITLE), message)
end

-- Get host informations
function NotesObject:getHostInformations()
	self.hostinfo = SV:getHostInfo()
	self.osType = self.hostinfo.osType  -- "macOS", "Linux", "Unknown", "Windows"
	self.osName = self.hostinfo.osName
	self.hostName = self.hostinfo.hostName
	self.languageCode = self.hostinfo.languageCode
	self.hostVersion = self.hostinfo.hostVersion
	self.hostVersionNumber = self.hostinfo.hostVersionNumber
end

-- Clear internal logs
function NotesObject:logsClear()
	self.logs = {}
end

-- Get object properties (debug only)
function NotesObject:getObjectProperties(obj, level)
	local result = ""
	local level = level or 0
	local maxLevel = 3
	level = level + 1
	
	if obj ~= nil then
		for k, v in pairs(obj) do
			if obj[k] ~= nil then
				result = result .. "(level: " .. level .. ") " .. k .. "=" .. tostring(v) .. "\r"
				if type(v) == "table" then
					-- result = result .. ", size:" .. #v .. ": "
					if level < maxLevel then
						result = result .. self:getObjectProperties(v, level) .. "\r"
					else
						result = result .. "\r"
					end
				end
			end
		end
	end
	return result
end
	
-- Get selected groups
function NotesObject:getSelectedGroups()	
	return SV:getArrangement():getSelection():getSelectedGroups()
end

-- Get current track
function NotesObject:getCurrentTrack()
	return SV:getMainEditor():getCurrentTrack()
end

-- Get timeAxis
function NotesObject:getTimeAxis()
	return self:getProject():getTimeAxis()
end

-- Get project
function NotesObject:getProject()
	return SV:getProject()
end

-- Get scale selected
function NotesObject:getScaleSelected()
	
	self.keyScaleSelected	= self:getkeyScaleChoiceFromPos(self.posKeyInScaleForm)
	self.posKeyInScale		= self:getKeyPosInKeynames(self.keyNames, self.keyScaleSelected) -- C = 1	

	self.keyScaleTypeSelected		= self.controls.scaleKeyType.value:getValue() + 1
	self.keyScaleTypeTitleSelected 	= self.scales[self.keyScaleTypeSelected].name
	self.keyScaleTypeValuesSelected	= self.scales[self.keyScaleTypeSelected].val

	self.currentKeyNames = self:copyTable(self.keyNames)
	
	-- Rotate table content, start note to new key
	self:shiftTable(self.currentKeyNames, self.posKeyInScale - 1) -- C = 1 - 1 = 0
	self.keysInScale = self:getKeysInScale(self.currentKeyNames)
end

-- Get group key scale 
function NotesObject:getGroupKeyScale()
	local scaleKeyResult = "" -- To display key scale found in TextArea
	local keyScaleFound = ""
	local keyFoundDisplay = ""
	local keyScaleFoundTrack = ""
	
	local trackName = ""
	if self:getCurrentTrack() ~= nil then
		trackName = self:getCurrentTrack():getName() .. " - "
	end
	scaleKeyResult = scaleKeyResult  .. trackName .. SV:T("Groups") 
						.. " (" .. #self.groupsSelected .. ")" .. "\r"	
	
	local keysInfosNew = self:getKeysInfos() -- check key scale in notes
	
	keyScaleFound		= keysInfosNew.keyScaleFound
	keyFoundDisplay		= keysInfosNew.keyFoundDisplay
	keyScaleFoundTrack	= keysInfosNew.keyScaleFoundTrack
	
	if #keyScaleFound > 0 then
		scaleKeyResult = scaleKeyResult  .. keyFoundDisplay .. "\r"
	else
		scaleKeyResult = scaleKeyResult  .. SV:T("No common scale key found!") .. "\r"
	end
	-- Display key scale found in TextArea
	self.controls.scaleKeyFound.value:setValue(scaleKeyResult)
	
	local keysInfos = { 
		keyScaleFound		= keyScaleFound,
		keyFoundDisplay		= keyFoundDisplay, 
		keyScaleFoundTrack	= keyScaleFoundTrack,
		scaleKeyResult		= scaleKeyResult
	}

	return keysInfos
end

-- Create a new track
function NotesObject:createTrack()
	local newTrack = SV:create("Track")
	newTrack:setDisplayColor(self.currentColor)
	
	self:getProject():addTrack(newTrack)
	return newTrack
end

-- Clone track from track reference
function NotesObject:cloneTrack()
	local newTrack = self.newTrackRef:clone()
	newTrack:setDisplayColor(self.currentColor)
	self:getProject():addTrack(newTrack)
	return newTrack
end

-- Get harmony list
function NotesObject:getHarmonyList()
	local resultList = {}
	for iList = 1, #self.transposition do
		table.insert(resultList, self.transposition[iList][self.transpositionRefLabel])
	end
	return resultList
end

-- Get track list
function NotesObject:getTracksList()
	local list = {}
	local formatCount = "%3d"
	local iTracks = self:getProject():getNumTracks()
	
	for iTrack = 1, iTracks do
		local track = self:getProject():getTrack(iTrack)
		local numGroups = track:getNumGroups() - 1
		local format = formatCount .. " " .. SV:T("groups")
		if numGroups < 2 then
			format = formatCount .. " " .. SV:T("group")
		end
		table.insert(list, track:getName() .. " (" .. string.format(format, numGroups) .. ")" )
	end
	return list
end

-- Get scale from title
function NotesObject:getScaleFromTitle(scaleSearch)
	local scale = {}
	for key, scale in ipairs(self.scales) do
		if scaleSearch == scale.name then
			scale = self.scales[key]
		end
	end
	return scale
end

-- get scale Key Found in choice format
function NotesObject:getKeyScaleChoice(keyScaleFound)
	local choice = {}
	if string.find(keyScaleFound, self.SEP_KEYS) == nil then
		table.insert(choice, keyScaleFound)
	else
		choice = self:split(keyScaleFound, self.SEP_KEYS)
	end
	return choice
end

-- Get keys data infos
function NotesObject:getKeysInfos()
	local keyScaleFound = ""
	local keyFoundDisplay = ""
	local keyScaleFoundTrack = ""		

	-- Check groups selected
	if #self.groupsSelected > 0 then
		
		-- Group selected
		keyScaleFound = self:getScaleGroup(self.groupsSelected)
		
		-- Track notes to check
		keyScaleFoundTrack = self:getScaleTrack(self.groupsSelected)
		
		keyFoundDisplay = keyScaleFound
		
		self.isOnlyOneKeyFound = false
		self.isTrackKeyFound = false

		if string.find(keyScaleFound, self.SEP_KEYS) == nil then
			self.isOnlyOneKeyFound = true
		end

		if keyScaleFound == "" then
			keyFoundDisplay = SV:T("No scale key found!")
		else
			
			if #keyScaleFoundTrack > 0 then
				if keyScaleFound ~= keyScaleFoundTrack then
					keyFoundDisplay = keyScaleFound .. "\r" .. SV:T("Track: ") .. keyScaleFoundTrack
					self.isTrackKeyFound = true
				end
			end
		end
	end
	
	local keysInfos = { 
			keyScaleFound = keyScaleFound,
			keyFoundDisplay = keyFoundDisplay, 
			keyScaleFoundTrack = keyScaleFoundTrack
		}
	return keysInfos
end

-- Get next measure Position
function NotesObject:getNextMeasurePos(current_time, timeMeasureBar)
	local notesLength =  16
	local newtime =  current_time
	local current_time_Int = math.floor(current_time)
	
	local new_next_time = current_time_Int
	local maxTime = notesLength * 10
	for i = 1, maxTime do
		if current_time <= new_next_time then
			newtime = new_next_time
			break
		end
		new_next_time = timeMeasureBar * (i + current_time_Int)
	end
	return newtime
end

-- Get current project tempo
function NotesObject:getProjectTempo(seconds)
	local tempoActive = 120
	local blicks = self:getTimeAxis():getBlickFromSeconds(seconds)
	local tempoMarks = self:getTimeAxis():getAllTempoMarks()
	for iTempo = 1, #tempoMarks do
		local tempoMark = tempoMarks[iTempo]
		if tempoMark ~= nil and blicks >= tempoMark.position then
			tempoActive = tempoMark.bpm
		end
	end
	return math.floor(tempoActive)
end

-- Get last group
function NotesObject:getLastGroup(track)
	local lastGroup = nil
	local numGroups = track:getNumGroups()
	if numGroups > 1 then
		lastGroup = track:getGroupReference(numGroups)
	end
	return lastGroup
end

-- Generate group for test only
function NotesObject:findTrackTest(title)
	local trackFound = nil
	local numTracks = self:getProject():getNumTracks()
	
	for iTrack = 1, numTracks do
		local track = self:getProject():getTrack(iTrack)
		if string.find(track:getName(), title) ~= nil then
			trackFound = track
			break
		end
	end
	return trackFound
end

-- Get first mesure after first note (or next position + n)
function NotesObject:getFirstMesure(notePos, nextPos)
	local measurePos = 0
	local measureBlick = 0
	local measureFirst = self:getTimeAxis():getMeasureAt(notePos) + nextPos
	local checkExistingMeasureMark = self:getTimeAxis():getMeasureMarkAt(measureFirst)
	
	if checkExistingMeasureMark ~= nil then
		if checkExistingMeasureMark.position == measureFirst then
			measurePos = checkExistingMeasureMark.position
			measureBlick = checkExistingMeasureMark.positionBlick
		else 
			self:getTimeAxis():addMeasureMark(measureFirst, 
						checkExistingMeasureMark.numerator, 
						checkExistingMeasureMark.denominator)
			local measureMark = self:getTimeAxis():getMeasureMarkAt(measureFirst)
			measurePos = measureMark.position
			measureBlick = measureMark.positionBlick
			self:getTimeAxis():removeMeasureMark(measureFirst)
		end
	else
		-- Temporary measure mark addition
		self:getTimeAxis():addMeasureMark(measureFirst, 4, 4)
		local measureMark = self:getTimeAxis():getMeasureMarkAt(measureFirst)
		measurePos = measureMark.position
		measureBlick = measureMark.positionBlick
		self:getTimeAxis():removeMeasureMark(measureFirst)
	end
	return measureBlick
end

-- Get group reference in time position
function NotesObject:getGroupRef(track, time)
	local groupRefFound = nil
	local numGroups = track:getNumGroups()
	local blicksPos = self:getTimeAxis():getBlickFromSeconds(time)
	
	-- All groups except the main group
	for iGroup = 1, numGroups do
		local groupRef = track:getGroupReference(iGroup)
		local blickSeconds = self:getTimeAxis():getSecondsFromBlick(groupRef:getOnset())
		
		-- Get group on timing pos
		if blicksPos >= groupRef:getOnset() and blicksPos <= groupRef:getEnd() then
			groupRefFound = groupRef
			break
		end
	end						
	return groupRefFound
end

-- Get next group start position
function NotesObject:getNextGroupStartPosition(track, gapInSecond, measureBarTime)
	local startPosition = 0
	local lastGroup = self:getLastGroup(track)

	if lastGroup ~= nil then
		local lastGroupPosition = self:getTimeAxis():getSecondsFromBlick(lastGroup:getEnd())
		if lastGroupPosition ~= nil then
			local checkGroup = self:getGroupRef(track, lastGroupPosition)
			if checkGroup ~= nil then
				startPosition = self:getNextMeasurePos(lastGroupPosition + gapInSecond, measureBarTime)
			end
		end
	end
	return startPosition
end

-- Generate group for test only
function NotesObject:generateGroupForTestOnly()
	-- Create group of notes in a new track
	-- with selected scale and scale type
	local startPosition = 0
	local duration = SV.QUARTER -- self:getTimeAxis():getBlickFromSeconds(0.1)
	local BPM = self:getProjectTempo(0)
	local BPM_ratio = 120 / BPM
	local measureBarTime = BPM_ratio / 16
	local gapInSecond = BPM/60

	-- Find existing group in track test
	self.trackTest = self:findTrackTest(self.trackTestTitle)
	
	if self.trackTest == nil then
		self.trackTest = self:createTrack()
		self.trackTest:setName(self.trackTestTitle)
		
		self.currentColor = self:getNewColor(self:getCurrentTrack())
		self.trackTest:setDisplayColor(self.currentColor)
	else
		startPosition = self:getNextGroupStartPosition(self.trackTest, gapInSecond, measureBarTime)
	end
	
	-- Create group
	local noteGroup = SV:create("NoteGroup")
	local scaleKeys = self.keyScaleTypeValuesSelected
	local notePitch = 60 + self.posKeyInScaleForm
	
	local timePos = 0
	local firstNote = nil
	local lastNote = nil
	-- self:show("#scaleKeys: " .. #scaleKeys .. ", scaleKeys: " .. table.concat(scaleKeys, ",") )
	
	for iKeyType = 1, #scaleKeys do
		local new_next_time = self:getNextMeasurePos(timePos, measureBarTime)  -- Get next measure position
		local notePitch = notePitch + scaleKeys[iKeyType]
		local key = self.keyNames[notePitch % 12 + 1]
		local note = SV:create("Note")
		note:setPitch(notePitch)
		note:setOnset(self:getTimeAxis():getBlickFromSeconds(new_next_time))
		note:setLyrics(key)
		note:setDuration(duration)
		noteGroup:addNote(note)
		timePos = self:getTimeAxis():getSecondsFromBlick(note:getEnd())
		
		if iKeyType == 1 then
			firstNote = note
		end
		lastNote = note
	end
	noteGroup:setName(self.keyScaleSelected .. " " .. self.keyScaleTypeTitleSelected)
	self:getProject():addNoteGroup(noteGroup)
	
	-- Add group reference to project new track
	local newGrouptRef = SV:create("NoteGroupReference", noteGroup)
	
	-- Define start & end group length
	local startPositionBlicks = self:getTimeAxis():getBlickFromSeconds(startPosition)
	local endPositionBlicks = lastNote:getOnset() + lastNote:getDuration() - firstNote:getOnset()
	-- New end position to next bar
	local newEndPosition = self:getFirstMesure(endPositionBlicks, 1) - 10
	newGrouptRef:setTimeOffset(startPositionBlicks)
	newGrouptRef:setTimeRange(startPositionBlicks, newEndPosition) -- v2.1.1

	self.trackTest:addGroupReference(newGrouptRef)
	
end

-- Duplicate and transpose notes
function NotesObject:duplicateNotes(groupsSelected)
	local trackChoice = 0
	local numGroups = 0
	local pitchTarget = self.pitchSelected

	self.currentColor = self:getNewColor(self:getCurrentTrack())
	self.isFixed = (pitchTarget == "Fixed")
	self.isNegativeHarmony = (pitchTarget == "Negative")
	
	local pitchTargets = self:split(pitchTarget, ",")
	if #pitchTargets > 1 then
		isMultipleTracks = true -- force for "build your own"
	end

	if string.len(self.keyScaleSelected) == 0 then
		self:show(SV:T("Error: No scale key found!"))
		return -1
	end
	if self.posKeyInScale < 0 then
		self:show(SV:T("Error: Position into scale error!"))
		return self.posKeyInScale
	end
	
	local formatCount = "%3d"
	local iTracks = self:getProject():getNumTracks()
	
	if self.isTrackClone then
		self.newTrackRef = self:cloneTrackReference()
	end

	-- Only one track to add
	if not isMultipleTracks then
		local track = nil
		
		local newGroupRefs = self:groupLoop(groupsSelected, self.isFixed, pitchTarget, self.posKeyInScale)
		-- New track
		if #self.trackListChoice == trackChoice or trackChoice == 0 then
			if self.isTrackClone then
				track = self:cloneTrack()
			else
				track = self:createTrack()
			end
			local trackNumber = iTracks + 1
			track:setName(self.trackNameHarmony .. trackNumber .. " (" .. pitchTarget .. ")")
		else
			track = self:getProject():getTrack(trackChoice)
		end
		
		for iGroupRef = 1, #newGroupRefs do
			track:addGroupReference(newGroupRefs[iGroupRef])
			numGroups = numGroups + 1
		end
	else
		-- add multiple tracks
		for iTrack = 1, #pitchTargets do
			local track = nil
			
			pitchTarget = self:trim(pitchTargets[iTrack])
			self.isFixed = (pitchTarget == "Fixed")
			self.isNegativeHarmony = (pitchTarget == "Negative")
			local newGroupRefs = self:groupLoop(groupsSelected, self.isFixed, pitchTarget, self.posKeyInScale)
			if self.isTrackClone then
				track = self:cloneTrack()
			else
				track = self:createTrack()
			end
			local trackNumber = iTrack + 1
			track:setName(self.trackNameHarmony .. trackNumber .. " (" .. pitchTarget .. ")")
			
			for iGroupRef = 1, #newGroupRefs do
				track:addGroupReference(newGroupRefs[iGroupRef])
				numGroups = numGroups + 1
			end
		end
	end
	
	if self.isTrackClone then
		self:deleteClonedTrack()
	end

	return numGroups
end

-- Clone track to keep current track voice
function NotesObject:cloneTrackReference()
	local newTrack = self:getCurrentTrack():clone()
	local iGroups = newTrack:getNumGroups()
	
	if iGroups > 1 then
		-- Delete groups
		while iGroups > 1 do
			local groupRef = newTrack:getGroupReference(iGroups)
			local index = groupRef:getIndexInParent()
			if groupRef ~= nil and not groupRef:isMain() then
				newTrack:removeGroupReference(index)
				iGroups = newTrack:getNumGroups()
			end
		end
	end
	
	newTrack:setName("Track voice ref")
	self:getProject():addTrack(newTrack)

	return newTrack
end

-- Delete track reference
function NotesObject:deleteClonedTrack()
	local result = false
	if self.newTrackRef ~= nil then
		local index = self.newTrackRef:getIndexInParent()
		self:getProject():removeTrack(index)
		result = true
	end
	return result
end

-- Loop into groups to duplicate & transpose notes
function NotesObject:groupLoop(groupsSelected, isFixed, pitchTarget, posKeyInScale)
	local newGroupRefs = {}
	self.firstNegativeNote = 0
	
	for _, refGroup in pairs(groupsSelected) do
		-- local groupName = refGroup:getTarget():getName()
		local noteGroup = refGroup:getTarget()
		local groupRefTimeoffset = refGroup:getTimeOffset()

		-- Clone source group
		local newNoteGroup = noteGroup:clone()
		local selectedNotes = newNoteGroup:getNumNotes()
		
		if selectedNotes >= 0 then
		
			-- Duplicate transposed notes into a new track to create
			-- Tranpose notes
			local firstNote = newNoteGroup:getNote(1)
			local lastNote = newNoteGroup:getNote(selectedNotes)
			local firstNotePitch = firstNote:getPitch()
			for iNote = 1, selectedNotes do
				local note = newNoteGroup:getNote(iNote)
				-- Get new pitch
				local notePitch = self:getNewPitch(isFixed, firstNotePitch, note:getPitch(), 
													tonumber(pitchTarget), posKeyInScale)
				note:setPitch(notePitch)
			end
			self:getProject():addNoteGroup(newNoteGroup)
			
			-- Add group reference to project new track
			local newGrouptRef = SV:create("NoteGroupReference", newNoteGroup)
			
			-- Adjust time offset
			newGrouptRef:setTimeOffset(groupRefTimeoffset)
			
			-- Adjust time range & voice attributes
			newGrouptRef:setTimeRange(refGroup:getOnset(), refGroup:getDuration())
			newGrouptRef:setVoice(refGroup:getVoice())
			
			if #self.languageOverride > 0 then
				-- Update notes language
				self:updateNotesLanguageOverride(newNoteGroup)
			end
						
			-- AI retakes
			if self.retakes then
				-- Update AI retakes
				self:updateAIRetakes(newNoteGroup)
			end
			
			table.insert(newGroupRefs, newGrouptRef)
		end
	end

	return newGroupRefs
end

-- Update notes language override
function NotesObject:updateNotesLanguageOverride(newNoteGroup)
	
	for iNote = 1, newNoteGroup:getNumNotes() do
		local note = newNoteGroup:getNote(iNote)
		note:setLanguageOverride(self.languageOverride)
	end
end

-- Update AI Retakes for new group note harmony
function NotesObject:updateAIRetakes(newNoteGroup)
	
	for iNote = 1, newNoteGroup:getNumNotes() do
		local note = newNoteGroup:getNote(iNote)
		local retakeListNote = note:getRetakes()
			if retakeListNote ~= nil then
				-- Generate new AI retakes
				local takeId = retakeListNote:generateTake(self.newDurationRetakes, self.newPitchRetakes, self.newTimbreRetakes)
				retakeListNote:setActiveTake(takeId)
			end
	end
end

-- Trim string
function NotesObject:trim(s)
  return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
end

-- Scale tools
-- Pitch note is in scale
function NotesObject:isInScale(pitch, keyScaleTypeValues, posKeyInScale)
	local inScale = false
	for key = 1, #keyScaleTypeValues do
		if pitch % 12 == (keyScaleTypeValues[key] + posKeyInScale) % 12 then
			inScale = true
			break
		end
	end
	return inScale
end

-- Key note is in scale
function NotesObject:isKeyInScale(keyPos, keyScaleTypeValues)
	local inScale = false
	-- 0,2,4,5,7,9,11
	for key = 1, #keyScaleTypeValues do
		if keyScaleTypeValues[key] == keyPos then
			inScale = true
			break
		end
	end
	return inScale
end

-- Get next note in scale
function NotesObject:getNextNoteInScale(keyPos, keyScaleTypeValues)
	local nextNote = keyScaleTypeValues[1]
	for key = 1, #keyScaleTypeValues do
		if keyScaleTypeValues[key] > keyPos then
			nextNote = keyScaleTypeValues[key]
			break
		end
	end
	return nextNote
end

-- GetScale in current track
function NotesObject:getScaleTrack(groupsSelected)
	return self:getScale(groupsSelected, "track")
end

-- GetScale in current group
function NotesObject:getScaleGroup(groupsSelected)
	return self:getScale(groupsSelected, "group")
end

-- Get Scale
function NotesObject:getScale(groupsSelected, paramTrack)
	local groupOrTrackNotes = "None"
	local scaleFound = ""
	local notes = {}
	local sep = ""
	local trackinfos = ""

	if paramTrack == "track" then
		-- Use current track
		groupOrTrackNotes = "Track"
		-- Loop through groups in track
		local numGroups = self:getCurrentTrack():getNumGroups()
		local refGroupTrack = nil
		trackinfos = SV:T("Groups") .. " (" .. numGroups .. ")"
		
		for grp = 1, numGroups do
			refGroupTrack = self:getCurrentTrack():getGroupReference(grp)
			self:addNotes(notes, refGroupTrack)
		end
	else
		-- paramTrack == "group"
		-- Groups selected
		if #groupsSelected > 0 then
			groupOrTrackNotes = SV:T("Groups") .. " (" .. #groupsSelected .. ")"
			for _, group in pairs(groupsSelected) do
				self:addNotes(notes, group)
			end
		else
			self:show(SV:T("No group selected!"))
		end
	end
	
	local oldScaleFoundItem = ""
	-- loop each scales
	for key = 1, #self.keyNames do
		local isInScale = false
		local scaleFoundItem = ""
		for j, keyScaleTypeValues in ipairs(self.scales) do
			
			-- Limit scale detection to activated detection
			if keyScaleTypeValues.detection then
				-- Limit to major scales or all activated scales
				if (self.isDetectionMajorScaleOnly and keyScaleTypeValues.name == "major") 
					or not self.isDetectionMajorScaleOnly then
					
					-- Loop on pitch notes
					isInScale = self:loopNotes(notes, keyScaleTypeValues.val, key - 1)
					if isInScale then
						-- scale found
						scaleFoundItem = scaleFoundItem .. sep .. self.keyNames[key]
						if self.isDetectionMajorScaleOnly then
							if keyScaleTypeValues.name == "major" then
								scaleFoundItem = scaleFoundItem .. " (" .. self:getKeyMajToMinor(self.keyNames[key]) .. ")"
							end
						else
							scaleFoundItem = scaleFoundItem .. " " .. keyScaleTypeValues.name
						end
						sep = self.SEP_KEYS
					end
				end
			end
		end
		if oldScaleFoundItem ~= scaleFoundItem then
			scaleFound = scaleFound .. scaleFoundItem
		end
		oldScaleFoundItem = scaleFoundItem
	end

	return scaleFound
end

-- Append notes from group
function NotesObject:addNotes(notes, refGroup)
	-- Check group type
	if refGroup ~= nil and not refGroup:isInstrumental() then
		local notesGroup = refGroup:getTarget()
		-- Store group notes
		for note = 1, notesGroup:getNumNotes() do
			local pitchNote = notesGroup:getNote(note):getPitch()
			if pitchNote ~= nil then
				table.insert(notes, pitchNote)
			end
		end
	end
end

-- Get new pitch in key scale
function NotesObject:getNewPitch(isFixed, firstNotePitch, notePitch, pitchTarget, posKeyInScale)
	if isFixed then 
		-- Fix all notes from the first note found
		notePitch = firstNotePitch
	else
		notePitch = self:getNextKeyInScale(self.keyScaleSelected, notePitch, pitchTarget, posKeyInScale)
	end
	return notePitch
end

-- Calculate scale reflexion axe
function NotesObject:getScaleAxis(scale)
    local first = scale[1]
    local fifth = scale[5] or (first + 7) % 12
    
    -- Axe in midway between tonic & fifth
    local axis = (first + fifth) / 2
    
    return axis
end

-- Get scale from tonic
function NotesObject:getScaleFromTonic(tonicValue, scalePattern)
    local scale = {}
    for i, interval in ipairs(scalePattern) do
        local noteValue = tonicValue + interval
		noteValue = noteValue % 12
        scale[i] = noteValue
    end
    
    return scale
end

-- Get closest note in range
function NotesObject:getClosestNote(firstNegativeNote, notePitchNew)
	local diffMain = {}
	local range = {24, 12, 0, -12, -24}
	local bFirst = true
	local minValue = 0
	local diff = 0
	local gap = 0
	
	-- Create range with gap values
	for i, val in ipairs(range) do
		diff = math.abs(firstNegativeNote - (notePitchNew + val))
		if bFirst then
			minValue = diff
			gap = val
		else
			minValue = math.min(minValue, diff)
			if minValue == diff then
				gap = val
			end
		end
		bFirst = false
	end
	
	return notePitchNew + gap
end

-- Get next valid key in scale
function NotesObject:getNextKeyInScale(keyScaleFound, notePitch, pitchTarget, posKeyInScale)
	local notePitchNew = notePitch 
	
	-- NOT negative harmony
	if not self.isNegativeHarmony then
		local octave = 0
		-- Octave -1
		if pitchTarget < 0 then
			pitchTarget = 7 + pitchTarget
			octave = -12
		end
			
		local gapDegree = self:getShiftDegrees(pitchTarget, notePitch)
		notePitchNew = notePitch + gapDegree + octave
	else
		-- Negative Harmony
		local scaleFromTonic = self:getScaleFromTonic(posKeyInScale)
        
		-- Calculate reflexion axe
		local axis = self:getScaleAxis(scaleFromTonic)
        -- Octave
        local pitchPos = notePitch % 12

		-- Calculate reflexion around axe
        local reflected = 2 * axis - pitchPos
        reflected = math.floor(reflected + 0.5)
		reflected = reflected % 12

		local notePitchNewTemp = notePitch - (notePitch % 12) + reflected
		
		if self.firstNegativeNote == 0 then
			self.firstNegativeNote = notePitchNewTemp
		end
		notePitchNew = self:getClosestNote(self.firstNegativeNote, notePitchNewTemp)
		
	end
	return notePitchNew
end

-- Get shifted degrees
function NotesObject:getShiftDegrees(pitchTarget, notePitch)
	local shift = 0
	local newNotePitch = notePitch

	-- Update notes outer scales
	if self.isUpdateNotesOuterScale then
	
		-- Is in scale
		if not self:isInScale(notePitch, self.keyScaleTypeValuesSelected, self.posKeyInScale -1) then
			local keypos = notePitch % 12 -- Get note
			-- Get next note in scale
			local newKeypos = self:getNextNoteInScale(keypos, self.keyScaleTypeValuesSelected)
			local updateNote = newKeypos - keypos
			-- Update to pitch
			newNotePitch = notePitch + updateNote
			-- shift to scale degree
			shift = shift + updateNote
		end
	end
	
	if pitchTarget > 0 then
		local keyScaleTypeGaps = self:getKeyScaleTypeToGap(self.keyScaleTypeValuesSelected)

		-- shift in scale degree
		local noteKey = self:getKeyFromPitch(newNotePitch)
		local posKeyInScaleKey = self:getKeyPosInKeynames(self.keysInScale, noteKey) -- key pos in degrees (1 to 7)
		
		for key = 1, pitchTarget do
			-- Add all gaps to get shifting note
			local dec = (posKeyInScaleKey + key - 2) % (#self.keyScaleTypeValuesSelected) + 1
			-- {0,2,4,5,7,9,11} => {2, 2, 1, 2, 2, 2, 1}
			--                     {2, 1, 2, 2, 1, 2, 2} "Natural Minor" 
			shift = shift + keyScaleTypeGaps[dec]
		end
	end
	
	return shift
end

-- Get key scale type to gap values
function NotesObject:getKeyScaleTypeToGap(keyScaleTypeValues)
	-- {0,2,4,5,7,9,11} => {2, 2, 1, 2, 2, 2, 1}
	local keyScaleGaps = {}
	
	for iKey = 1, #keyScaleTypeValues do
		local diff = 0
		if iKey + 1 > #keyScaleTypeValues then
			diff = 12 - keyScaleTypeValues[iKey]
		else
			diff = keyScaleTypeValues[iKey + 1] - keyScaleTypeValues[iKey]
		end
		-- 0 + 1 => 2 - 0 = 2
		table.insert(keyScaleGaps, diff)
	end
	return keyScaleGaps
end

-- Get key pitch
function NotesObject:getKeyFromPitch(notePitch)
	local pitchPos = notePitch % 12
	return self.keyNames[pitchPos + 1]
end

-- loop for each notes
function NotesObject:loopNotes(notes, keyScaleTypeValues, posKeyInScale)
	local isInScale = false
	-- loop all notes
	for note = 1, #notes do
		local notePitch = notes[note]
		if notePitch ~= nil then
			isInScale = self:isInScale(notePitch, keyScaleTypeValues, posKeyInScale)
			if not isInScale then
				break
			end
		end
	end
	return isInScale
end

-- Get key position in Keynames
function NotesObject:getKeyPosInKeynames(keyNames, keyfound)
	local posKeyInScale = 1
	-- loop each scales
	for key = 1, #keyNames do
		if keyfound == keyNames[key] then
			posKeyInScale = key
			break
		end
	end
	return posKeyInScale
end

-- Get key scale found from position self.keyScaleChoice
function NotesObject:getkeyScaleChoiceFromPos(scaleKeyPosInput)
	local keyScaleFound = ""
	for iPos = 1, #self.keyScaleChoice do
		if scaleKeyPosInput == iPos -1 then
			keyScaleFound = self.keyScaleChoice[iPos]
		end
	end
	return keyScaleFound
end

-- Get keys in scale
function NotesObject:getKeysInScale(currentKeyNames)
	local keysInScale = {}
	for key = 1, #currentKeyNames do
		if self:isKeyInScale(key - 1, self.keyScaleTypeValuesSelected) then
			table.insert(keysInScale, currentKeyNames[key])
		end
	end
	return keysInScale
end

-- Key tools
-- Get Key from minor to major
function NotesObject:getKeyMinToMaj(key)
	local arrKeys = self.relativeKeys
	
	for iMaj, kMin in pairs(arrKeys) do
		if key == kMin[2] then
			keyResult = kMin[1]
		end
	end	
	return keyResult
end

-- Get Key from major to minor
function NotesObject:getKeyMajToMinor(key)
	local arrKeys = self.relativeKeys
	
	for iMaj, kMin in pairs(arrKeys) do
		if key == kMin[1] then
			keyResult = kMin[2]
		end
	end	
	return keyResult
end

-- Get pitch action from position
function NotesObject:getPitchActionFromPos(pos, harmonyChoice)
	return self.transposition[harmonyChoice][self.transpositionRefData][pos + 1]
end

-- Split string by sep char
function NotesObject:split(str, sep)
	local result = {}
	local regex = ("([^%s]+)"):format(sep)
	for each in str:gmatch(regex) do
		table.insert(result, each)
	end
	return result
end

-- Rotate table content
function NotesObject:shiftTable(tInput, num)
	for iPos = 1, math.abs ( num ) do
		if num < 0 then
			table.insert ( tInput, 1, table.remove ( tInput ) )
		else
			table.insert ( tInput, table.remove ( tInput, 1 ) )
		end
	end
end

-- Duplicate table
function NotesObject:copyTable(tInput)
	local tOutput = {}
	for k, v in pairs(tInput) do
		table.insert(tOutput, k, v)
	end
	return tOutput
end

-- Add log into self.logs
function NotesObject:addLogs(message)
	table.insert(self.logs, message)
	self:addTextPanel(message)
end

-- Display logs into panel
function NotesObject:addLogsInPanel()
	for i = 1, #self.logs do
		self:addTextPanel(self.logs[i])
	end
end

-- Display message box in panel
function NotesObject:addTextPanel(message)
	local old = self.statusTextValue:getValue()
	local sepLine = "\r"
	if #old > 0 then
		message = old .. sepLine .. message
	end
	self.statusTextValue:setValue(message)
end

-- Clear display message in panel
function NotesObject:clearTextPanel()
	self.statusTextValue:setValue("")
end

-- Store error message
function NotesObject:error(message)
	table.insert(self.errorMessages, message)
end

-- Get controls panel
function NotesObject:getControls()
	-- TextArea: Key found 						scaleKeys
	-- ComboBox: Select a key scale				scaleKeyChoice
	-- ComboBox: Key scale type					scaleKeyType
	-- Slider:   Pitch transposition			pitch
	-- ComboBox: Harmony type					harmonyChoice
	-- CheckBox: Update notes outer scale		isUpdateNotesOuterScale
	-- CheckBox: use current track as source	isTrackClone
	-- TextArea: status text 					statusTextValue
	
	local controls = {
		scaleKeyFound = {						-- TextArea: Key found
			value = SV:create("WidgetValue"),
			defaultValue = "",
			paramKey = "scaleKeyFound"
		},
		isDetectionMajorScaleOnly = {			-- CheckBox: Detection major scale only
			value = SV:create("WidgetValue"),
			defaultValue = true,
			paramKey = "isDetectionMajorScaleOnly"
		},
		scaleKeyChoice = {						-- ComboBox: Select a key scale
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- C
			paramKey = "scaleKeyChoice"
		},
		scaleKeyType = {						-- ComboBox: Key scale type
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- major
			paramKey = "scaleKeyType"
		},
		harmonyChoice = {						-- ComboBox: Harmony type
			value = SV:create("WidgetValue"),
			defaultValue = 0,
			paramKey = "harmonyChoice"
		},
		multiplePitchChoice = {					-- ComboBox: Multiple notes for Harmony type
			value = SV:create("WidgetValue"),
			defaultValue = 0,
			paramKey = "multiplePitchChoice"
		},
		trackChoice = {							-- ComboBox: Destination track
			value = SV:create("WidgetValue"),
			defaultValue = 0, 
			paramKey = "trackChoice"
		},
		pitch = {								-- Slider: Pitch value
			value = SV:create("WidgetValue"),
			defaultValue = 0, 
			paramKey = "pitchChoice"
		},
		transpositionSelected = {				-- TextArea: transposition selected
			value = SV:create("WidgetValue"),
			defaultValue = 0, 
			paramKey = "transpositionSelected"
		},
		isUpdateNotesOuterScale = {				-- CheckBox: Update notes outer scale
			value = SV:create("WidgetValue"),
			defaultValue = true,
			paramKey = "isUpdateNotesOuterScale"
		},
		isTrackClone = {						-- CheckBox: Use current track as source
			value = SV:create("WidgetValue"),
			defaultValue = false,
			paramKey = "isTrackClone"
		}
	}
	return controls
end

-- Initialize widget values
function NotesObject:initializeControlsValues()
	-- Initialize widget values
	for key, control in pairs(self.controls) do
		control.value:setValue(control.defaultValue)
	end
end

-- Set controls callback (TODO)
function NotesObject:setControlsCallback()
	for key, control in pairs(self.controls) do
		control.value:setValueChangeCallback(function()
				-- self:addLogsInPanel()
								
				if control.paramKey == "isDetectionMajorScaleOnly" then
					self.isDetectionMajorScaleOnly = self.controls.isDetectionMajorScaleOnly.value:getValue()
				end
				
				if control.paramKey == "pitchChoice" then
					self.pitchSelectedType = control.paramKey
					self.pitchSelected = string.format("%i", self.controls.pitch.value:getValue())
					
					-- Display SV:T("Selected") .. ": " .. pitchSelected
					self.controls.transpositionSelected.value:setValue(self.pitchSelectedLabel 
						.. string.format("%i", self.pitchSelected))
					
					-- Reset harmonyChoice value because user select "pitch" only "one note" for harmonyChoice
					self.controls.harmonyChoice.value:setValue(0)
					self.controls.multiplePitchChoice.value:setValue(0)
					self.displayMultiplePitchChoice = false
					SV:refreshSidePanel()
				end
				
				if control.paramKey == "harmonyChoice" then
					self.pitchSelectedType = control.paramKey
					self.transpositionSelected = self.controls.harmonyChoice.value:getValue() + 1
					-- {SV:T("1 note"),  8, {}},
					if self.transpositionSelected == 1 then
						self.pitchSelected = string.format("%i", self.controls.pitch.value:getValue())
					else
						self.pitchSelected = self.transposition[self.transpositionSelected][self.transpositionRefData][1]
					end

					-- Reset simple transposition value because user select "harmonyChoice" double notes
					self.controls.pitch.value:setValue(0)
					
					if self.pitchSelected == "Fixed" or self.transpositionSelected == 1 
						or self.pitchSelected == "Negative" then
						self.displayMultiplePitchChoice = false
					else
						-- Add new ComboBox for multiple pitch choice
						self.displayMultiplePitchChoice = true
					end
					self.controls.multiplePitchChoice.value:setValue(0)
					self.controls.transpositionSelected.value:setValue(self.pitchSelectedLabel .. self.pitchSelected)
					SV:refreshSidePanel()
				end
				
				if control.paramKey == "multiplePitchChoice" then
					self.pitchSelectedType = control.paramKey
					local transpositionSelected = self.controls.multiplePitchChoice.value:getValue() + 1
					self.pitchSelected = self.transposition[self.transpositionSelected][self.transpositionRefData][transpositionSelected]
					-- Display SV:T("Selected") .. ": " .. pitchSelected
					self.controls.transpositionSelected.value:setValue(self.pitchSelectedLabel .. self.pitchSelected)
					
					-- Reset simple transposition value because user select "harmonyChoice" double notes
					self.controls.pitch.value:setValue(0)
				end
				if control.paramKey == "scaleKeyType" then
					self.keyScaleTypeSelected = self.controls.scaleKeyType.value:getValue() + 1
				end
			end
		)
	end
end

-- Set button apply control callback
function NotesObject:setButtonApplyControlCallback()

	-- Button create harmony
	self.applyButtonValue:setValueChangeCallback(function()
			self:getProject():newUndoRecord()
			self.resultDebug = ""

			self.groupsSelected = self:getSelectedGroups()
			
			if #self.groupsSelected > 0 then
				self.posKeyInScaleForm = self.controls.scaleKeyChoice.value:getValue()

				self.isTrackClone = self.controls.isTrackClone.value:getValue()
				self.isUpdateNotesOuterScale = self.controls.isUpdateNotesOuterScale.value:getValue()
				
				local keysInfos = self:getGroupKeyScale()
				
				-- Get user selected scale
				self:getScaleSelected()
				
				-- Duplicate note groups & create tracks
				local numGroups = self:duplicateNotes(self.groupsSelected)
				
				if self.debug then SV:setHostClipboard(self.resultDebug) end
			else
				-- No group selected
				self.controls.scaleKeyFound.value:setValue(self.defaultKeyFoundMessage)
				self:show(self.defaultKeyFoundMessage)
			end
		end
	)
end

-- Set button Generate group control callback
function NotesObject:setButtonGenerateGroupControlCallback()

	-- Button generate group harmony
	self.generateGroupButtonValue:setValueChangeCallback(function()
			self:getProject():newUndoRecord()

			self.posKeyInScaleForm = self.controls.scaleKeyChoice.value:getValue()
			self.isTrackClone = self.controls.isTrackClone.value:getValue()
			
			local keysInfos = self:getGroupKeyScale()
			-- Get user selected scale
			self:getScaleSelected()
			
			-- Generate group for test
			local numGroups = self:generateGroupForTestOnly()
			
		end
	)
end

-- Display message
function NotesObject:displayMessage(message)
	self:clearTextPanel()
	self:addTextPanel(self.infosToDisplay)
	self:addTextPanel(message)
end
	
-- Get combo box data
function NotesObject:getComboLists()
	self.scalesList = {}
	
	-- scales list
	for key, scale in ipairs(self.scales) do
		table.insert(self.scalesList, scale.name)
	end
end

-- Display error messages
function NotesObject:displayErrors()
	local result = ""
	if #self.errorMessages > 0 then
		for _, m in pairs(self.errorMessages) do
			result = result .. m .. "\r"
		end
	end
	return result
end

-- Get new color
function NotesObject:getNewColor(track)
	if self.currentColorPos == 0 then 
		self.currentColorPos = self:getCurrentColorPos(track)
	end
	self.currentColorPos = self.currentColorPos + 1
	if self.currentColorPos > #self.colors then
		self.currentColorPos = 1
	end
	return self.colors[self.currentColorPos].val
end

-- Get current color position
function NotesObject:getCurrentColorPos(track)
	local newPos = 1
	for i, color in ipairs(self.colors) do
		if color.val == track:getDisplayColor() then
			newPos = i
			break
		end
	end	
	return newPos
end

-- Get colors
function NotesObject:getColors()
	local colors = {}
	table.insert(colors, {val = "ffd14f5b", name = "red"})
	table.insert(colors, {val = "ffc27455", name = "orange"})
	table.insert(colors, {val = "ffc27455", name = "ocher"})
	table.insert(colors, {val = "ffd6bc43", name = "yellow"})
	table.insert(colors, {val = "ff7db235", name = "green"})
	table.insert(colors, {val = "ff3bb26c", name = "greenish"})
	table.insert(colors, {val = "ff3eb2a8", name = "blue-sky"})
	table.insert(colors, {val = "ff4794cb", name = "blue"})
	table.insert(colors, {val = "ff5478c7", name = "turquoise"})
	table.insert(colors, {val = "ff6959d4", name = "purple"})
	table.insert(colors, {val = "ffb853b3", name = "pink"})
	return colors
end


-- Create user input form
function NotesObject:getSectionContainer()
	local scaleKeyType = {}
	local pitchMinValue = -7
	local pitchMaxValue = 7
	local pitchInterval = 1

	-- TextArea: Key found 						scaleKeys
	-- ComboBox: Select a key scale				scaleKeyChoice
	-- ComboBox: Key scale type					scaleKeyType
	-- Slider:   Pitch transposition			pitch
	-- ComboBox: Harmony type					harmonyChoice
	-- CheckBox: use current track as source	isTrackClone
	-- button:   apply							applyButtonValue
	-- button:   generate group					generateGroupButtonValue
	-- TextArea: status text 					statusTextValue
	
	self.controls.scaleKeyFound.value:setValue(self.defaultKeyFoundMessage)

	local scaleKeyFound =
		{
			type = "Container",
			columns = {
				{
					type = "TextArea",
					value = self.controls.scaleKeyFound.value,
					height = 100,
					width = 1.0,
					readOnly = true
				}
			}
		}

	self.controls.isDetectionMajorScaleOnly.value:setValue(self.isDetectionMajorScaleOnly)
	local detectionLimited = 
		{
			type = "Container",
			columns = {
				{
				type = "CheckBox",
				text = SV:T("Major scales only detection"),
				value = self.controls.isDetectionMajorScaleOnly.value,
				width = 1.0
				}
			}
		}

	local scaleKeyChoice =
		{
			type = "Container",
			columns = {
				{
					type = "ComboBox",
					text = SV:T("Select a key scale"),
					value = self.controls.scaleKeyChoice.value,
					choices = self.keyScaleChoice,
					width = 0.3
				},
				{
					type = "ComboBox",
					text = SV:T("Key scale type"),
					value = self.controls.scaleKeyType.value,
					choices = self.scalesList,
					width = 0.7
				}
			}
		}

	self.controls.isTrackClone.value:setValue(self.isCurrentVoiceTrack)
	local trackClone = 
		{
			type = "Container",
			columns = {
				{
				type = "CheckBox",
				text = SV:T("Get current voice for new tracks"),
				value = self.controls.isTrackClone.value,
				width = 1.0
				}
			}
		}

	self.controls.isUpdateNotesOuterScale.value:setValue(self.isUpdateNotesOuterScale)
	local updateNotesOuter = 
		{
			type = "Container",
			columns = {
				{
				type = "CheckBox",
				text = SV:T("Update notes outer scale"),
				value = self.controls.isUpdateNotesOuterScale.value,
				width = 1.0
				}
			}
		}
		
	local transpositionSelected =  
		{
			type = "Container",
			columns = {
				{
					type = "TextArea",
					value = self.controls.transpositionSelected.value,
					height = 20,
					width = 1.0,
					readOnly = false
				}
			}
		}

	local harmonyChoice = 
		{
			type = "Container",
			columns = {
				{
					type = "ComboBox",
					text = SV:T("Harmony type"),
					value = self.controls.harmonyChoice.value,
					choices = self.harmonyList,
					width = 1.0
				}
			}
		}
	
	
	local multiplePitchChoice = {}
	
	if self.displayMultiplePitchChoice then
		local transpositionList = self.transposition[self.transpositionSelected][self.transpositionRefData]
		multiplePitchChoice = 
			{
				type = "Container",
				columns = {
					{
						type = "ComboBox",
						text = SV:T("Harmony type"),
						value = self.controls.multiplePitchChoice.value,
						choices = transpositionList,
						width = 1.0
					}
				}
			}
	end
	
	local pitchChoice = 
		{
			type = "Container",
			columns = {
				{
					type = "Slider",
					text = SV:T("Transpose (-7 to +7)"),
					format = "%3.0f pitch",
					minValue = pitchMinValue, 
					maxValue = pitchMaxValue, 
					interval = pitchInterval,
					value = self.controls.pitch.value,
					width = 1.0
				}
			}
		}
	
	local trackTest = {}
	if self.trackTestActive	then
		trackTest = 
			{
				type = "Container",
				columns = {
					{
						type = "Button",
						text = SV:T("Generate group"),
						width = 1.0,
						value = self.generateGroupButtonValue
					}
				}
			}
	end

	-- Define CheckBox & button & textarea
	local section = {
		title = SV:T(SCRIPT_TITLE),
		rows = {
			{
				type = "Label",
				text = SV:T("Detection: Select a group"),
			},
			scaleKeyFound,
			detectionLimited,
			{
				type = "Label",
				text = SV:T("Action: Select a scale and type"),
			},			
			scaleKeyChoice,
			pitchChoice,
			harmonyChoice,
			multiplePitchChoice,
			transpositionSelected,
			updateNotesOuter,
			trackClone,
			{
				type = "Container",
				columns = {
					{
						type = "Button",
						text = SV:T("Apply"),
						width = 1.0,
						value = self.applyButtonValue
					}
				}
			},
			trackTest,
			{
				type = "Container",
				columns = {
					{
						type = "TextArea",
						value = self.statusTextValue,
						height = 40,
						width = 1.0,
						readOnly = true
					}
				}
			}
		}
	}
	return section
end

-- Get panel section state
function NotesObject:getPanelSectionState()
	self:logsClear()
	self.applyButtonValue:setEnabled(true)
	self.generateGroupButtonValue:setEnabled(true)
	
	local section = self:getSectionContainer()

	local errors = self:displayErrors()
	if #errors > 0 then
		self:addTextPanel(errors)
	end
	
	return section
end

-- Initialize main internal object	
local notesObject = NotesObject:new()

-- Get panel section state called by Synthesizer V internal system
function getSidePanelSectionState()

	local section = notesObject:getPanelSectionState()
	return section
end
