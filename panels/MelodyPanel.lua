local SCRIPT_TITLE = '.Melodies'

--[[

Synthesizer V Studio Pro Script
 
lua file name: MelodyPanel.lua

Melody Generator in Lua with Variable Spacing
Generates melodies based on scale, style, and rhythm
Includes variable spacing between notes based on rhythm and style

Update: Added a ComboBox "Note fixed to measure bar 1/16 to 1/64.
		Improve notes position fixed on timed bar measures related to BPM
		
Notice: Works only with script panel 
		introduced with Synthesizer V version >= 2.1.2

2025 - JF AVILES
--]]

function getClientInfo()
	return {
		name = SV:T(SCRIPT_TITLE),
		-- category = "_JFA_Panels",
		author = "JFAVILES",
		versionNumber = 4,
		minEditorVersion = 131329,
		type = "SidePanelSection"
	}
end

-- Generated by JFA TranslateScripts.lua
function getTranslations(langCode)
	return getArrayLanguageStrings()[langCode]
end

-- Generated by JFA TranslateScripts.lua
function getArrayLanguageStrings()
	return {
		["en-us"] = {
			{"Version", "Version"},
			{"author", "author"},
			{"minEditorVersion", "minEditorVersion"},
			{"Generate melodies", "Generate melodies"},
			{"major", "major"},
			{"natural minor", "natural minor"},
			{"blues major", "blues major"},
			{"dorian", "dorian"},
			{"phrygian", "phrygian"},
			{"melodic minor", "melodic minor"},
			{"harmonic minor", "harmonic minor"},
			{"ionian", "ionian"},
			{"locrian", "locrian"},
			{"lydian", "lydian"},
			{"mixolydian", "mixolydian"},
			{"aeolian", "aeolian"},
			{"blues minor", "blues minor"},
			{"japanese", "japanese"},
			{"chinese", "chinese"},
			{"chinese 2", "chinese 2"},
			{"indian", "indian"},
			{"hungarian major", "hungarian major"},
			{"Style pop", "Style pop"},
			{"Style ballad", "Style ballad"},
			{"Style edm", "Style edm"},
			{"Style jazz", "Style jazz"},
			{"Speed fast", "Speed fast"},
			{"Speed medium", "Speed medium"},
			{"Speed slow", "Speed slow"},
			{"Length short", "Length short"},
			{"Length normal", "Length normal"},
			{"Length long", "Length long"},
			{"Octave down", "Octave down"},
			{"Octave base", "Octave base"},
			{"Octave up", "Octave up"},
			{"Note fixed: 1/16", "Note fixed: 1/16"},
			{"Note fixed: 1/32", "Note fixed: 1/32"},
			{"Note fixed: 1/64", "Note fixed: 1/64"},
			{"Group created!", "Group created!"},
			{"Error: Empty group, nothing created!", "Error: Empty group, nothing created!"},
			{"Select a key scale:", "Select a key scale:"},
			{"Auto play melody", "Auto play melody"},
			{"Loop into melody", "Loop into melody"},
			{"Apply", "Apply"},
			{"Select a key scale", "Select a key scale"},
			{"Select a scale type", "Select a scale type"},
			{"Select a style", "Select a style"},
			{"Select a rhythm", "Select a rhythm"},
			{"Select melody length", "Select melody length"},
			{"Select octave (down:-1, base:0, up:+1)", "Select octave (down:-1, base:0, up:+1)"},
			{"Note position to measure bar", "Note position to measure bar"},
		},
	}
end

-- Define a class "NotesObject"
NotesObject = {
	playBack = nil,
	playHeadPosition = nil,
	displayVersion = true,	-- display version
	displayAuthor = false,	-- display author
	currentSeconds = 0,
	defaultLyrics = "la",
	octaveRange = 1,
	quarterDivider = 4,
	measureBarVal = 8,		-- Place notes on starting measure bar 1/8
	minTimeSpacing = 1/8,	-- default minimum time(s) between notes
	BPM = 120,				-- Beat per minute
	errorMessages = {},
	currentPlayheadSeconds = 0,
	beginGroup = nil,
	endGroup = nil,
	hostinfo = nil,
	osType = "",
	osName = "",
	hostName = "",
	languageCode = "", 
	hostVersion = "",
	hostVersionNumber = 0,
	debug = false,
	saved_melodies = {},	-- Storage for generated melodies
	keyNames = {},			-- {"C", "Db", "D" ...
	note_names = {},		-- ["C"] = 60, ["Db"] = 61,
	allscalesActive = false, -- true to list all scales
	scales = {},
	styles = {},	
	rhythms = {},
	melodyNotesLength = 0,
	melodyLength = {},
	octaveUpDown = {},
	measureBar = {},
	scalesList = {},
	stylesList = {},
	rhythmsList = {},
	melodyLengthList = {},
	octaveUpDownList = {},
	controls = {},				-- controls panel
	applyButtonValue = nil, 	-- button apply
	statusTextValue = nil,   	-- text panel
	keyScaleChoice = {},
	styleChoice = {},
	melodyLengthChoice = {},
	measureBarChoice = {},
	lyricsException = {},
	infosToDisplay = "",
	logs = {}
}

-- Define a class "NoteEvent"
NoteEvent = {
	event = nil,
	parent = nil -- NotesObject
}

-- Define a class "Melody"
Melody = {
	id = 0,
	melody = nil,
	melody_counter = 0,
	parent = nil -- NotesObject
}

-- Constructor method for the NotesObject class
function NotesObject:new()
    local notesObject = {}
    setmetatable(notesObject, self)
    self.__index = self
	
	self:getHostInformations()
	
	-- Get playhead first measure
	self.currentSeconds = self:getPlayhead()
	
	self.keyNames = {"C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"}
	self.lyricsException = {"+", "++", "-", "br", "'", ".cl", ".pau", ".sil"}
	
	-- Note names with values
	self.note_names = {
		["C"] = 60, ["Db"] = 61, -- ["C#"] = 61, 
		["D"] = 62, ["Eb"] = 63, -- ["D#"] = 63, 
		["E"] = 64,
		["F"] = 65, ["Gb"] = 66, -- ["F#"] = 66, 
		["G"] = 67, ["Ab"] = 68, -- ["G#"] = 68, 
		["A"] = 69, ["Bb"] = 70, -- ["A#"] = 70,
		["B"] = 71
	}
	
	self.scales = self:getScalesData(self.allscalesActive) -- init activated scales or all
	self.styles = self:getStylesData()
	self.rhythms = self:getRhythmsData()
	self.melodyLength = self:getMelodyLengthData()
	self.octaveUpDown = self:getOctaveUpDownData()
	self.measureBar = self:getMeasureBarData()

	self.controls = self:getControls()
	
	self:initializeControlsValues()
	self:setControlsCallback()
	
	self.applyButtonValue = SV:create("WidgetValue")
	self.statusTextValue = SV:create("WidgetValue")
	self.statusTextValue:setValue("")
	self.statusTextValue:setEnabled(false)
	
	self:setButtonApplyControlCallback()
	
	-- load combox data
	self:getComboLists()
	
	local infos = getClientInfo()

	self.infosToDisplay = ""
	if self.displayVersion then
		self.infosToDisplay = self.infosToDisplay .. SV:T("Version") .. ": " ..  infos.versionNumber
		if self.displayAuthor then
			self.infosToDisplay = self.infosToDisplay .. " - " .. SV:T("author") .. ": " .. infos.author
		end
	end
	-- self.infosToDisplay = self.infosToDisplay .. SV:T("minEditorVersion") .. ": " ..  infos.minEditorVersion
	self:addTextPanel(self.infosToDisplay)
	self:addTextPanel(SV:T("Generate melodies") .. "...")
	
    return self
end

-- Show message dialog
function NotesObject:show(message)
	SV:showMessageBox(SV:T(SCRIPT_TITLE), message)
end

-- Get selected groups
function NotesObject:getSelectedGroups()	
	return SV:getArrangement():getSelection():getSelectedGroups()
end

-- Get current track
function NotesObject:getCurrentTrack()
	return SV:getMainEditor():getCurrentTrack()
end

-- Get timeAxis
function NotesObject:getTimeAxis()
	return self:getProject():getTimeAxis()
end

-- Get project
function NotesObject:getProject()
	return SV:getProject()
end

-- Add log into self.logs
function NotesObject:addLogs(message)
	table.insert(self.logs, message)
end

-- Display logs into panel
function NotesObject:addLogsInPanel()
	for i = 1, #self.logs do
		self:addTextPanel(self.logs[i])
	end
end

-- Display message box in panel
function NotesObject:addTextPanel(message)
	local old = self.statusTextValue:getValue()
	local sepLine = "\r"
	if #old > 0 then
		message = old .. sepLine .. message
	end
	self.statusTextValue:setValue(message)
end

-- Clear display message in panel
function NotesObject:clearTextPanel()
	self.statusTextValue:setValue("")
end

-- Store error message
function NotesObject:error(message)
	table.insert(self.errorMessages, message)
end

-- Get controls panel
function NotesObject:getControls()

	local controls = {
		autoPlay = {
			value = SV:create("WidgetValue"),
			defaultValue = false,
			paramKey = "autoPlay"
		},
		loopAutoPlay = {
			value = SV:create("WidgetValue"),
			defaultValue = false,
			paramKey = "loopAutoPlay"
		},
		scaleKey = {
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- C
			paramKey = "scaleKey"
		},
		scaleType = {
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- major
			paramKey = "scale"
		},
		style = {
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- pop
			paramKey = "style"
		},
		rhythm = {
			value = SV:create("WidgetValue"),
			defaultValue = 1, -- medium
			paramKey = "rhythm"
		},
		melodyLength = {
			value = SV:create("WidgetValue"),
			defaultValue = 1, -- normal = 16
			paramKey = "melodyLength"
		},
		octaveUpDown = {
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- Octave down = 0
			paramKey = "octaveUpDown"
		},
		measureBar = {
			value = SV:create("WidgetValue"),
			defaultValue = 0, -- measureBar = 8
			paramKey = "measureBar"
		}
	}
	return controls
end

-- Initialize widget values
function NotesObject:initializeControlsValues()
	-- Initialize widget values
	for key, control in pairs(self.controls) do
		control.value:setValue(control.defaultValue)
		-- self:addLogs(key .. "=" .. tostring(control.defaultValue))
		-- self:addLogs(key .. "=" .. self:getObjectProperties(control))
	end
end

-- Set controls callback
function NotesObject:setControlsCallback()
	for key, control in pairs(self.controls) do
		control.value:setValueChangeCallback(function()
			-- do something may be
				-- self:addLogsInPanel()
				if control.paramKey == "style" then
					-- Update scale type from style scale_preference
					local styleChoice = self.stylesList[control.value:getValue() + 1]
					local style = self.styles[control.value:getValue() + 1]
					local scale_preference = style.val.scale_preference
					local posScale = self:getPosScaleFromScaleName(scale_preference)
					self.controls.scaleType.value:setValue(posScale - 1)
				end
			end
		)
	end
end

-- Display message
function NotesObject:displayMessage(message)
	self:clearTextPanel()
	self:addTextPanel(self.infosToDisplay)
	self:addTextPanel(message)
end

-- Get key position in Keynames
function NotesObject:getKeyPosInKeynames(keyNames, keyfound)
	local posKeyInScale = -1
	-- loop each scales
	for key = 1, #keyNames do
		if keyfound == keyNames[key] then
			posKeyInScale = key
			break
		end
	end
	return posKeyInScale
end

-- Get position in scale array from scale name
function NotesObject:getPosScaleFromScaleName(style)
	local pos = 0
	for i = 1, #self.scales do
		if self.scales[i].name == style then
			pos	= i
			break
		end
	end
	return pos
end

-- Set button Apply control callback
function NotesObject:setButtonApplyControlCallback()

	-- Button create melody
	self.applyButtonValue:setValueChangeCallback(function()
			self:getProject():newUndoRecord()
			
			self:createMelody(self.controls.scaleKey.value:getValue(),
				self.controls.scaleType.value:getValue(), self.controls.style.value:getValue(), 
				self.controls.rhythm.value:getValue(), self.controls.melodyLength.value:getValue(), 
				self.controls.octaveUpDown.value:getValue(),
				self.controls.measureBar.value:getValue()
				)
		end
	)
end
	
-- Get scales data
function NotesObject:getScalesData(allscalesActive)
	local scales = {}
	
	local scalesReference = {
		-- KeyScale type, Intervals
		{name = SV:T("major"), 			val = {0,2,4,5,7,9,11}, active = true},
		{name = SV:T("natural minor"),	val = {0,2,3,5,7,8,10}, active = true},
		{name = SV:T("blues major"),	val = {0,2,3,4,7,9}, 	active = true},
		{name = SV:T("dorian"),			val = {0,2,3,5,7,9,10}, active = true},
		{name = SV:T("phrygian"),		val = {0,1,3,5,7,8,10}, active = true},
		{name = SV:T("melodic minor"),	val = {0,2,3,5,7,9,11}, active = false},
		{name = SV:T("harmonic minor"),	val = {0,2,3,5,7,8,11}, active = false},
		{name = SV:T("ionian"),			val = {0,2,4,5,7,9,11}, active = false},
		{name = SV:T("locrian"),		val	= {0,1,3,5,6,8,10}, active = false},
		{name = SV:T("lydian"),			val = {0,2,4,6,7,9,11}, active = false},
		{name = SV:T("mixolydian"),		val	= {0,2,4,5,7,9,10}, active = false},
		{name = SV:T("aeolian"),		val	= {0,2,3,5,7,8,10}, active = false},
		{name = SV:T("blues minor"),	val	= {0,3,5,6,7,10}, 	active = false},
		{name = SV:T("japanese"),		val	= {0,1,5,7,8}, 		active = false},
		{name = SV:T("chinese"),		val	= {0,2,4,7,9}, 		active = false}, 
		{name = SV:T("chinese 2"),		val	= {0,4,6,7,11}, 	active = false},
		{name = SV:T("indian"),			val	= {0,1,3,4,7,8,10}, active = false},
		{name = SV:T("hungarian major"),val = {0,3,4,6,7,9,10}, active = false}
	}
	
	-- loop to active scales
	for i = 1, #scalesReference do
		if allscalesActive or scalesReference[i].active then
			table.insert(scales, scalesReference[i])
		end
	end

	return scales
end

-- Get styles data
function NotesObject:getStylesData()
	local styles = {}
	
	local stylesReference = { 
		{name = SV:T("Style pop"), val = {
			scale_preference = "major",
			octave_range = 1,
			jump_probability = 0.3,
			repetition_chance = 0.4,
			rhythm_complexity = 0.5,
			base_spacing = 0.08,	-- Spacing configurations
			spacing_variation = 0.1,
			syncopation_chance = 0.2,
			staccato_chance = 0.4
		}},
		{name = SV:T("Style ballad"), val = {
			scale_preference = "natural minor",
			octave_range = 1,
			jump_probability = 0.2,
			repetition_chance = 0.5,
			rhythm_complexity = 0.3,
			base_spacing = 0.15,	-- Spacing configurations
			spacing_variation = 0.2,
			syncopation_chance = 0.1,
			staccato_chance = 0.2
		}},
		{name = SV:T("Style edm"), val = {
			scale_preference = "natural minor", -- Note names to MIDI mapping
			octave_range = 2,
			jump_probability = 0.4,
			repetition_chance = 0.3,
			rhythm_complexity = 0.7,
			base_spacing = 0.1,        -- Spacing configurations, Base silence between notes
			spacing_variation = 0.15,  -- Random variation in spacing
			syncopation_chance = 0.4,  -- Probability of syncopated rhythm
			staccato_chance = 0.6      -- Probability of short, detached notes
		}},
		{name = SV:T("Style jazz"), val = {
			scale_preference = "dorian",
			octave_range = 2,
			jump_probability = 0.6,
			repetition_chance = 0.2,
			rhythm_complexity = 0.8,
			base_spacing = 0.05,		-- Spacing configurations
			spacing_variation = 0.25,
			syncopation_chance = 0.7,
			staccato_chance = 0.3
		}}
	}
	
	-- loop into data
	for i = 1, #stylesReference do
			table.insert(styles, stylesReference[i])
	end
	
	return styles
end

-- Get rhythms data
function NotesObject:getRhythmsData()
	local rhythms = {}
	
	local rhythmsReference = {
		{name = SV:T("Speed fast"), val = {
			durations = {0.25, 0.5, 0.5, 0.25, 0.5}, -- Rhythm configurations (note durations and spacing multipliers)
			spacing_multiplier = 0.8,	-- Faster = less spacing
			groove_factor = 1.2			-- Slightly uneven timing
		}},
		{name = SV:T("Speed medium"), val = {
			durations = {0.5, 1, 0.5, 1, 0.5},
			spacing_multiplier = 1.0,
			groove_factor = 1.1
		}},
		{name = SV:T("Speed slow"), val = {
			durations = {1, 2, 1, 1.5, 2},
			spacing_multiplier = 1.5,	-- Slower = more breathing room
			groove_factor = 1.05
		}}
	}
	
	-- loop into data
	for i = 1, #rhythmsReference do
			table.insert(rhythms, rhythmsReference[i])
	end
	
	return rhythms
end

-- Get melodyLength data
function NotesObject:getMelodyLengthData()
	local melodyLength = {}
	
	local melodyLengthReference = {
		{name = SV:T("Length short"), val = 8 },
		{name = SV:T("Length normal"), val = 16 },
		{name = SV:T("Length long"), val = 32 }
	}
	
	-- loop into data
	for i = 1, #melodyLengthReference do
			table.insert(melodyLength, melodyLengthReference[i])
	end
	
	return melodyLength
end

-- Get octaveUpDown data
function NotesObject:getOctaveUpDownData()
	local octaveUpDown = {}
	
	local octaveUpDownReference = {
		{name = SV:T("Octave down"), val = -1 },
		{name = SV:T("Octave base"), val = 0 },
		{name = SV:T("Octave up"), val = 1 }
	}
	
	-- loop into data
	for i = 1, #octaveUpDownReference do
			table.insert(octaveUpDown, octaveUpDownReference[i])
	end
	
	return octaveUpDown
end

-- Get measure bar data
function NotesObject:getMeasureBarData()
	local measureBar = {}
	
	local measureBarReference = {
		{name = SV:T("Note fixed: 1/16"), val = 8 }, -- 8 in 1s (16 in 2s)
		{name = SV:T("Note fixed: 1/32"), val = 16 },
		{name = SV:T("Note fixed: 1/64"), val = 32 }
	}
	
	-- loop into data
	for i = 1, #measureBarReference do
			table.insert(measureBar, measureBarReference[i])
	end
	
	return measureBar
end

-- Get group reference in time position
function NotesObject:getGroupRef(track, time)
	local groupRefFound = nil
	local numGroups = track:getNumGroups()
	local blicksPos = self:getTimeAxis():getBlickFromSeconds(time)
	
	-- All groups except the main group
	for iGroup = 1, numGroups do
		local groupRef = track:getGroupReference(iGroup)
		local blickSeconds = self:getTimeAxis():getSecondsFromBlick(groupRef:getOnset())
		
		-- Get group on timing pos
		if blicksPos >= groupRef:getOnset() and blicksPos <= groupRef:getEnd() then
			groupRefFound = groupRef
			break
		end
	end						
	return groupRefFound
end

-- Get playhead position in first nearest measure
function NotesObject:getPlayhead()
	-- Get playhead first measure
	self.currentPlayheadSeconds = SV:getPlayback():getPlayhead()
	local currentBlick = self:getTimeAxis():getBlickFromSeconds(self.currentPlayheadSeconds)
	-- Get first measure
	local measureBlick = self:getFirstMesure(currentBlick, 0)
	local newPositionSeconds = self:getTimeAxis():getSecondsFromBlick(measureBlick)
	return newPositionSeconds
end

-- Display error messages
function NotesObject:displayErrors()
	local result = ""
	if #self.errorMessages > 0 then
		for _, m in pairs(self.errorMessages) do
			result = result .. m .. "\r"
		end
	end
	return result
end

-- Get host informations
function NotesObject:getHostInformations()
	self.hostinfo = SV:getHostInfo()
	self.osType = self.hostinfo.osType  -- "macOS", "Linux", "Unknown", "Windows"
	self.osName = self.hostinfo.osName
	self.hostName = self.hostinfo.hostName
	self.languageCode = self.hostinfo.languageCode
	self.hostVersion = self.hostinfo.hostVersion
	self.hostVersionNumber = self.hostinfo.hostVersionNumber
end

-- Constructor method for the NoteEvent class
function NoteEvent:new(midi_note, start_time, duration, velocity, parent)
    local noteEvent = {}
	self.__index = NoteEvent

    local event = {
        midi_note = midi_note,
        start_time = start_time,
        duration = duration,
        velocity = velocity or 80,
        end_time = start_time + duration
    }
    setmetatable(event, NoteEvent)
	self.event = event
	self.parent = parent -- NotesObject
    return event
end

-- Display note event content
function NoteEvent:display()
    return string.format("Note: %d, Start: %.3f, Duration: %.3f, End: %.3f", 
                        self.midi_note, self.start_time, self.duration, self.end_time)
end

-- Constructor method for the Melody class
function Melody:new(note_events, scale, style, rhythm, root_note, total_duration, parent)
    local melody = {}
	self.__index = Melody
	
    local melody = {
        id = self.melody_counter + 1,
        note_events = note_events,
        scale = scale,
        style = style,
        rhythm = rhythm,
        root_note = root_note,
        total_duration = total_duration,
        created_at = os.date("%Y-%m-%d %H:%M:%S")
    }
	
    setmetatable(melody, Melody)
	
	self.id = melody.id
	self.melody = melody
    self.melody_counter = self.melody_counter + 1
	self.parent = parent -- NotesObject
	
    return melody
end

-- Display melody content
function Melody:display()
	local result = ""
    result = result .. "Melody ID: " .. self.id .. "\r"
    result = result .. "Scale: " .. self.scale .. " | Style: " .. self.style .. " | Rhythm: " .. self.rhythm .. "\r"
    result = result .. "Root note: " .. self.root_note .. " (MIDI: " .. self.parent.note_names[self.root_note] .. ")" .. "\r"
    result = result .. "Total duration: " .. string.format("%.3f", self.total_duration) .. " beats" .. "\r"
    result = result .. "Created: " .. self.created_at .. "\r"
    result = result .. "Note Events:" .. "\r"
    
    for i, event in ipairs(self.note_events) do
        result = result .. "  " .. i .. ". " .. event:display() .. "\r"
    end
    result = result .. "---" .. "\r"
	return result
end

-- Get midi sequence
function Melody:get_midi_sequence()
    -- Returns simple arrays for compatibility
    local notes = {}
    local start_times = {}
    local durations = {}
    
    for _, event in ipairs(self.note_events) do
        table.insert(notes, event.midi_note)
        table.insert(start_times, event.start_time)
        table.insert(durations, event.duration)
    end
    
    return notes, start_times, durations
end

-- Get scale from scale type
function NotesObject:get_scale(scale_type)
	local scale = nil
	for i, v in ipairs(self.scales) do
		if v.name == scale_type then
			scale = v
			break
		end
	end
	return scale
end

-- Get style from style name
function NotesObject:get_style(style_name)
	local style = nil
	for i, v in ipairs(self.styles) do
		if v.name == style_name then
			style = v
			break
		end
	end
	return style
end

-- Get rhythm from rhythm name
function NotesObject:get_rhythm(rhythm_name)
	local rhythm = nil
	for i, v in ipairs(self.rhythms) do
		if v.name == rhythm_name then
			rhythm = v
			break
		end
	end
	return rhythm
end

-- Get melodyLength from melodyLength name
function NotesObject:get_melodyLength(melodyLength_name)
	local melodyLength = nil
	for i, v in ipairs(self.melodyLength) do
		if v.name == melodyLength_name then
			melodyLength = v
			break
		end
	end
	return melodyLength
end

-- Get octaveUpDown from octaveUpDown name
function NotesObject:get_octaveUpDown(octaveUpDown_name)
	local octaveUpDown = nil
	for i, v in ipairs(self.octaveUpDown) do
		if v.name == octaveUpDown_name then
			octaveUpDown = v
			break
		end
	end
	return octaveUpDown
end

-- Get measureBar name
function NotesObject:get_measureBar(measureBar_name)
	local measureBar = nil
	for i, v in ipairs(self.measureBar) do
		if v.name == measureBar_name then
			measureBar = v
			break
		end
	end
	return measureBar
end

-- Get scale notes in MIDI format
function NotesObject:get_scale_notes(root_note, scale_type, octaveUpDown)
    local root_midi = self.note_names[root_note]
    if not root_midi then
        self:error("Invalid root note: " .. root_note)
    end
    -- [1] = {name = "major", val = {0,2,4,5,7,9,11}},
    -- local scale_intervals = self.scales[scale_type].val or self.scales["major"].val
	-- self:show("scale_type: " .. scale_type)
	-- self:show("scale_name: " .. self:get_scale(scale_type).name)
	
    local scale_intervals = self:get_scale(scale_type).val
    local scale_notes = {}
    
    -- Generate notes across multiple octaves
    for octave = 0, self.octaveRange do
        for _, interval in ipairs(scale_intervals) do
            table.insert(scale_notes, root_midi + (octaveUpDown * 12) + interval + (octave * 12))
        end
    end
    
    return scale_notes
end

-- Calculate spacing between notes
function NotesObject:calculate_spacing(style_config, rhythm_config)
    local base_spacing = style_config.base_spacing * rhythm_config.spacing_multiplier
    
    -- Add variation
    local variation = (math.random() - 0.5) * style_config.spacing_variation
    local spacing = base_spacing + variation
    
    -- Apply syncopation (occasional off-beat emphasis)
    if math.random() < style_config.syncopation_chance then
        spacing = spacing + (math.random() * 0.1 - 0.05)
    end
    
    -- Apply groove factor (slight timing imperfections that feel human)
    local groove_variation = (math.random() - 0.5) * 0.02 * rhythm_config.groove_factor
    spacing = spacing + groove_variation
    
    -- Ensure spacing is not negative
    return math.max(0, spacing)
end

-- Calculate note duration with style modifications
function NotesObject:calculate_note_duration(base_duration, style_config, rhythm_config)
    local duration = base_duration
    
    -- Apply staccato effect (shortens notes)
    if math.random() < style_config.staccato_chance then
        duration = duration * (0.6 + math.random() * 0.3)  -- 60-90% of original duration
    end
    
    -- Add slight duration variation based on rhythm complexity
    local variation = (math.random() - 0.5) * 0.1 * style_config.rhythm_complexity
    duration = duration * (1 + variation)
    
    -- Apply groove factor to duration
    local groove_variation = (math.random() - 0.5) * 0.05 * rhythm_config.groove_factor
    duration = duration * (1 + groove_variation)
    
    return math.max(0.1, duration)  -- Ensure minimum duration
end

-- Generate a melody with variable spacing
function NotesObject:generate_melody(root_note, scale_type, style_name, 
										rhythm_name, length, octaveUpDown, measureBar)
    self.melodyNotesLength = length or 16  -- Default melody length
	self.measureBarVal = measureBar -- measure bar default 8 for 1/16
	
	self.currentSeconds = SV:getPlayback():getPlayhead()
	self.BPM = self:getProjectTempo(self.currentSeconds)
	
	-- 120/120 = 1, 120/90 = 1.333, 120/60 = 2
	local BPM_ratio = 120 / self.BPM
	-- 120 1/8 = 0.125  94 1.27/8=0.160   90 1.333/8=0.1666 60 2/8 = 0.25
	local measureBarTime = BPM_ratio / self.measureBarVal
	self.minTimeSpacing = measureBarTime
	-- self:addLogs("BPM_ratio: " .. BPM_ratio 
				-- .. ", measureBarVal:" .. self.measureBarVal 
				-- .. ", BPM: " .. self.BPM
				-- .. ", measureBarTime: " .. measureBarTime)
	
    -- Validate inputs
    if not self.note_names[root_note] then
        self:error("Invalid root note. Use: C, Db, D, Eb, E, F, Gb, G, Ab, A, Bb, B")
		return nil
    end
    if not self:get_scale(scale_type) then
        self:error("Invalid scale. Use: major, minor, dorian, blues_major, etc...")
		return nil
    end
	
    if not self:get_style(style_name) then
        self:error("Invalid style. Use: edm, jazz, pop, ballad")
		return nil
    end
    if not self:get_rhythm(rhythm_name) then
        self:error("Invalid rhythm. Use: fast, medium, slow")
		return nil
    end
	
	math.randomseed(os.time())
	
    local scale_notes = self:get_scale_notes(root_note, scale_type, octaveUpDown)
    local style_config = self:get_style(style_name).val
    local rhythm_config = self:get_rhythm(rhythm_name).val
    local rhythm_pattern = rhythm_config.durations
    
    local note_events = {}
    local current_time = 0
    local new_next_time = 0
    local current_note_index = math.random(1, #scale_notes)
	local newCurrent_note_index = 0
	local result = ""
	local iCurrentNote = 1

    for i = 1, self.melodyNotesLength do
		iCurrentNote = i
        -- Get base duration from rhythm pattern
        local duration_index = ((i - 1) % #rhythm_pattern) + 1
        local base_duration = rhythm_pattern[duration_index]
        
        -- Calculate actual note duration with style modifications
        local note_duration = self:calculate_note_duration(base_duration, style_config, rhythm_config)
        
		if new_next_time > 0 then
			current_time = new_next_time
		end
		
        -- Create note event
        local midi_note = scale_notes[current_note_index]
		result = result .. "midi_note: " .. midi_note
		result = result .. ", current_time: " .. current_time
		result = result .. ", note_duration: " .. note_duration
		result = result .. "\r"
        local velocity = 70 + math.random(20)  -- Random velocity 70-90
		
        -- Calculate spacing after this note
        local spacing = self:calculate_spacing(style_config, rhythm_config)
		-- result = result .. ", spacing: " .. spacing
		
        if spacing < self.minTimeSpacing then
			spacing = 0
			result = result .. ", new: " .. spacing
		end
		
        -- Update current time (note duration + spacing)
        local next_time = current_time + note_duration + spacing
		result = result .. ", next_time: " .. next_time
		
		-- Place next note to next measure bar 1/16
		new_next_time = self:getNextMeasurePos(next_time, measureBarTime)
		result = result .. ", new_next_time: " .. new_next_time .. "\r"
		
		-- Force duration to join notes (without space)
		if new_next_time > next_time then
			note_duration = note_duration + new_next_time - next_time
		end
		local note_event = NoteEvent:new(midi_note, current_time, note_duration, velocity, self)
		
        table.insert(note_events, note_event) -- Add note
	
		newCurrent_note_index = current_note_index
        -- Determine next note
        if math.random() < style_config.repetition_chance then
            -- Repeat current note (do nothing)
        elseif math.random() < style_config.jump_probability then
            -- Make a jump
            local jump_size = math.random(-5, 5)
            current_note_index = math.max(1, math.min(#scale_notes, current_note_index + jump_size))
        else
            -- Step movement
            local step = math.random() < 0.5 and -1 or 1
            current_note_index = math.max(1, math.min(#scale_notes, current_note_index + step))
        end
    end

	if self.debug then SV:setHostClipboard(result) end
	
    -- Create and save melody
    local melody = Melody:new(note_events, scale_type, style_name, rhythm_name, 
								root_note, current_time, self)
    table.insert(self.saved_melodies, melody)
    
    return melody
end

-- Generate a melody with variable spacing
function NotesObject:generate_melody1(root_note, scale_type, style_name, 
										rhythm_name, length, octaveUpDown, measureBar)
	self.melodyNotesLength = length or 16  -- Default melody length
	self.measureBarVal = measureBar -- measure bar default 8 for 1/16
	
	self.currentSeconds = SV:getPlayback():getPlayhead()
	self.BPM = self:getProjectTempo(self.currentSeconds)
	
	-- 120/120 = 1, 120/90 = 1.333, 120/60 = 2
	local BPM_ratio = 120 / self.BPM
	-- 120 1/8 = 0.125  94 1.27/8=0.160   90 1.333/8=0.1666 60 2/8 = 0.25
	local measureBarTime = BPM_ratio / self.measureBarVal
	self.minTimeSpacing = measureBarTime
	-- self:addLogs("BPM_ratio: " .. BPM_ratio 
				-- .. ", measureBarVal:" .. self.measureBarVal 
				-- .. ", BPM: " .. self.BPM
				-- .. ", measureBarTime: " .. measureBarTime)

    -- Validate inputs
    if not self.note_names[root_note] then
        self:error("Invalid root note. Use: C, Db, D, Eb, E, F, Gb, G, Ab, A, Bb, B")
		return nil
    end
    if not self:get_scale(scale_type) then
        self:error("Invalid scale. Use: major, minor, dorian, blues_major, etc...")
		return nil
    end
	
    if not self:get_style(style_name) then
        self:error("Invalid style. Use: edm, jazz, pop, ballad")
		return nil
    end
    if not self:get_rhythm(rhythm_name) then
        self:error("Invalid rhythm. Use: fast, medium, slow")
		return nil
    end
	
	math.randomseed(os.time())
	
    local scale_notes = self:get_scale_notes(root_note, scale_type, octaveUpDown)
    local style_config = self:get_style(style_name).val
    local rhythm_config = self:get_rhythm(rhythm_name).val
    local rhythm_pattern = rhythm_config.durations
    
    local note_events = {}
    local current_time = 0
    local new_next_time = 0
    local current_note_index = math.random(1, #scale_notes)
	local newCurrent_note_index = 0
	local result = ""
	
    for i = 1, self.melodyNotesLength do
        -- Get base duration from rhythm pattern
        local duration_index = ((i - 1) % #rhythm_pattern) + 1
        local base_duration = rhythm_pattern[duration_index]
        
        -- Calculate actual note duration with style modifications
        local note_duration = self:calculate_note_duration(base_duration, style_config, rhythm_config)
        
		if new_next_time > 0 then
			current_time = new_next_time
		end
		
        -- Create note event
        local midi_note = scale_notes[current_note_index]
		result = result .. "midi_note: " .. midi_note
		result = result .. ", current_time: " .. current_time
		result = result .. ", note_duration: " .. note_duration
		result = result .. "\r"
        local velocity = 70 + math.random(20)  -- Random velocity 70-90
		
        -- Calculate spacing after this note
        local spacing = self:calculate_spacing(style_config, rhythm_config)
		-- result = result .. ", spacing: " .. spacing
		
        if spacing < self.minTimeSpacing then
			spacing = 0
			result = result .. ", new: " .. spacing
		end
        -- Update current time (note duration + spacing)
        local next_time = current_time + note_duration + spacing
		result = result .. ", next_time: " .. next_time
		
		-- Place next note to next measure bar 1/8
		new_next_time = self:getNextMeasurePos(next_time, self.measureBarVal)
		result = result .. ", new_next_time: " .. new_next_time .. "\r"
		
		if new_next_time > next_time then
			note_duration = note_duration + new_next_time - next_time
		end

		local note_event = NoteEvent:new(midi_note, current_time, note_duration, velocity, self)
		
        table.insert(note_events, note_event)
	
		newCurrent_note_index = current_note_index
        -- Determine next note
        if math.random() < style_config.repetition_chance then
            -- Repeat current note (do nothing)
        elseif math.random() < style_config.jump_probability then
            -- Make a jump
            local jump_size = math.random(-5, 5)
            current_note_index = math.max(1, math.min(#scale_notes, current_note_index + jump_size))
        else
            -- Step movement
            local step = math.random() < 0.5 and -1 or 1
            current_note_index = math.max(1, math.min(#scale_notes, current_note_index + step))
        end
    end
	if self.debug then SV:setHostClipboard(result) end
	
    -- Create and save melody
    local melody = Melody:new(note_events, scale_type, style_name, rhythm_name, 
								root_note, current_time, self)
    table.insert(self.saved_melodies, melody)
    
    return melody
end

-- Get next measure Position
function NotesObject:getNextMeasurePos(current_time, timeMeasureBar)
	local newtime =  current_time
	local current_time_Int = math.floor(current_time)
	
	local new_next_time = current_time_Int
	local maxTime = self.melodyNotesLength * 10
	for i = 1, maxTime do
		if current_time <= new_next_time then
			newtime = new_next_time
			break
		end
		new_next_time = timeMeasureBar * (i + current_time_Int)
	end
	return newtime
end

-- Get current project tempo
function NotesObject:getProjectTempo(seconds)
	local blicks = self:getTimeAxis():getBlickFromSeconds(seconds)
	local tempoActive = 120
	local tempoMarks = self:getTimeAxis():getAllTempoMarks()
	for iTempo = 1, #tempoMarks do
		local tempoMark = tempoMarks[iTempo]
		if tempoMark ~= nil and blicks > tempoMark.position then
			tempoActive = tempoMark.bpm
		end
	end
	return math.floor(tempoActive)
end

-- List all saved melodies
function NotesObject:list_melodies()
    if #self.saved_melodies == 0 then
        self:error("No melodies saved yet.")
        return
    end
	
    local result = "=== SAVED MELODIES ==="  .. "\r"
    for _, melody in ipairs(self.saved_melodies) do
        result = result .. melody:display() .. "\r"
    end
	return result
end

-- Get a melody by ID
function NotesObject:get_melody(id)
    for _, melody in ipairs(self.saved_melodies) do
        if melody.id == id then
            return melody
        end
    end
    return nil
end

-- Delete a melody
function NotesObject:delete_melody(id)
    for i, melody in ipairs(self.saved_melodies) do
        if melody.id == id then
            table.remove(self.saved_melodies, i)
            -- Melody id deleted
            return true
        end
    end
    self:error("Melody " .. id .. " not found.")
    return false
end

-- Export melody with timing information
function NotesObject:export_melody(melody)
    if not melody then return nil end
    
    local notes, start_times, durations = melody:get_midi_sequence()
    
    local export_data = {
        id = melody.id,
        notes = notes,
        start_times = start_times,
        durations = durations,
        total_duration = melody.total_duration,
        scale = melody.scale,
        style = melody.style,
        rhythm = melody.rhythm,
        root_note = melody.root_note,
        note_events = {}
    }
    
    -- Export detailed note events
    for _, event in ipairs(melody.note_events) do
        table.insert(export_data.note_events, {
            midi_note = event.midi_note,
            start_time = event.start_time,
            duration = event.duration,
            end_time = event.end_time,
            velocity = event.velocity
        })
    end
    
    return export_data
end

-- Analyze melody timing
function NotesObject:analyze_melody_timing(melody)
    if not melody or #melody.note_events == 0 then
        self:error("No melody to analyze")
        return
    end
    local result = ""
    result = result .. "=== TIMING ANALYSIS ===" .. "\r"
    result = result .. "Melody ID: " .. melody.id .. "\r"
    result = result .. "Total duration: " .. string.format("%.3f", melody.total_duration) .. " beats" .. "\r"
    
    local gaps = {}
    for i = 2, #melody.note_events do
        local prev_event = melody.note_events[i-1]
        local curr_event = melody.note_events[i]
        local gap = curr_event.start_time - prev_event.end_time
        table.insert(gaps, gap)
    end
    
    if #gaps > 0 then
        local total_gap = 0
        local min_gap = gaps[1]
        local max_gap = gaps[1]
        
        for _, gap in ipairs(gaps) do
            total_gap = total_gap + gap
            min_gap = math.min(min_gap, gap)
            max_gap = math.max(max_gap, gap)
        end
        
        local avg_gap = total_gap / #gaps
        result = result .. "Average gap between notes: " .. string.format("%.3f", avg_gap) .. " beats" .. "\r"
        result = result .. "Minimum gap: " .. string.format("%.3f", min_gap) .. " beats" .. "\r"
        result = result .. "Maximum gap: " .. string.format("%.3f", max_gap) .. " beats" .. "\r"
    end
    
    result = result .. "---" .. "\r"
	return result
end

-- Get object properties (debug only)
function NotesObject:getObjectProperties(obj, level)
	local result = ""
	local level = level or 0
	local maxLevel = 3
	level = level + 1
	
	for k, v in pairs(obj) do
		if obj[k] ~= nil then
			result = result .. "(level: " .. level .. ") " .. k .. "=" .. tostring(v) .. "\r"
			if type(v) == "table" then
				-- result = result .. ", size:" .. #v .. ": "
				if level < maxLevel then
					result = result .. self:getObjectProperties(v, level) .. "\r"
				else
					result = result .. "\r"
				end
			end
		end
	end
	return result
end

-- Limit string max length
function NotesObject:limitStringLength(resultLyrics, maxLengthResult)
	-- Limit string max length
	if string.len(resultLyrics) > maxLengthResult then
		local posStringChar = string.find(resultLyrics," ", maxLengthResult - 10)
		if posStringChar == nil then posStringChar = maxLengthResult end
		resultLyrics = string.sub(resultLyrics, 1, posStringChar)
	end
	return resultLyrics
end

-- Check lyrics "a" less than .1s for special effect
function NotesObject:isLyricsEffect(note)
	local result = false
	local notelength = self:getTimeAxis():getSecondsFromBlick(note:getDuration())
	-- ie: 0.0635
	if notelength < 0.1 then
		result = true
	end
	return result
end

-- Is lyrics is a text accepted
function NotesObject:isTextAccepted(lyrics)
	local result = true
	
	-- Filter char '+' & '++' & '-' & 'br' & .cl & .pau & .sil
	for i, lyricsExcept in pairs(self.lyricsException) do
		if lyrics == lyricsExcept then
			result = false
			break
		end
	end

	return result
end

-- Get first mesure after first note (or next position + n)
function NotesObject:getFirstMesure(notePos, nextPos)
	local measurePos = 0
	local measureBlick = 0
	local measureFirst = self:getTimeAxis():getMeasureAt(notePos) + nextPos
	local checkExistingMeasureMark = self:getTimeAxis():getMeasureMarkAt(measureFirst)
	
	if checkExistingMeasureMark ~= nil then
		if checkExistingMeasureMark.position == measureFirst then
			measurePos = checkExistingMeasureMark.position
			measureBlick = checkExistingMeasureMark.positionBlick
		else 
			self:getTimeAxis():addMeasureMark(measureFirst, 
						checkExistingMeasureMark.numerator, 
						checkExistingMeasureMark.denominator)
			local measureMark = self:getTimeAxis():getMeasureMarkAt(measureFirst)
			measurePos = measureMark.position
			measureBlick = measureMark.positionBlick
			self:getTimeAxis():removeMeasureMark(measureFirst)
		end
	else
		-- Temporary measure mark addition
		self:getTimeAxis():addMeasureMark(measureFirst, 4, 4)
		local measureMark = self:getTimeAxis():getMeasureMarkAt(measureFirst)
		measurePos = measureMark.position
		measureBlick = measureMark.positionBlick
		self:getTimeAxis():removeMeasureMark(measureFirst)
	end
	return measureBlick
end

-- Rename one group
function NotesObject:renameOneGroup(maxLengthResult, noteGroup)
	local resultLyrics = ""
	local groupName = noteGroup:getName()
	local notesCount = noteGroup:getNumNotes()

	if notesCount > 0 then
		local lyricsLine = ""
		local sep = ""

		for i = 1, notesCount do
			local infos = ""
			local note = noteGroup:getNote(i)
			
			if note ~= nil then
				local lyrics = note:getLyrics()
				if string.len(lyrics) > 0 then
				
					-- Filter char '+' & '-' & 'br' & .cl & .pau & .sil
					if self:isTextAccepted(note) then
						-- Replace following note char '-'
						if lyrics == "-" then lyrics = ".." end 
						-- Add lyrics for each note
						lyricsLine = lyricsLine .. sep .. lyrics
						sep = " "
					end				  
				end
			end
		end

		-- Add lyrics
		resultLyrics = self:limitStringLength(lyricsLine, maxLengthResult)
		-- Update if new lyrics only
				if string.len(resultLyrics)> 0 and
			noteGroup:getName() ~= resultLyrics then
			noteGroup:setName(resultLyrics)
		end
	end

	return resultLyrics
end

-- Create group for new track with new notes
function NotesObject:createGroup(startPosition, track, melody)
	local maxLengthResult = 30
	
	-- Create new note group 
	local noteGroup = SV:create("NoteGroup")
	local lastNote = nil
	local firstNote = nil
	
	-- Loop into generated notes
	for i, event in ipairs(melody.note_events) do
		local note = SV:create("Note")
		note:setOnset(self:getTimeAxis():getBlickFromSeconds(event.start_time))
		note:setLyrics(self.defaultLyrics)
		note:setPitch(event.midi_note)
		note:setDuration(self:getTimeAxis():getBlickFromSeconds(event.duration))
		noteGroup:addNote(note)
		if i == 1 then 
			firstNote = note
		end
		lastNote = note
	end
	
	-- Set group name with existing lyrics notes
	noteGroup:setName("")
	self:getProject():addNoteGroup(noteGroup)
	local resultLyrics = self:renameOneGroup(maxLengthResult, noteGroup)
	
	-- Create note group reference
	local newGrouptRef = SV:create("NoteGroupReference", noteGroup)
	
	-- Define start & end group length
	local startPositionBlicks = self:getTimeAxis():getBlickFromSeconds(startPosition)
	local endPositionBlicks = lastNote:getOnset() + lastNote:getDuration() - firstNote:getOnset()
	-- New end position to next bar
	local newEndPosition = self:getFirstMesure(endPositionBlicks, 1) - 10
	newGrouptRef:setTimeOffset(startPositionBlicks)
	newGrouptRef:setTimeRange(startPositionBlicks, newEndPosition) -- v2.1.1
	
	-- Add group reference in current track
	track:addGroupReference(newGrouptRef)
	
	return newGrouptRef
end

-- Generate group
function NotesObject:generateGroup(root_note, scale_type, style_name, rhythm_name, 
									melodyLength_name, octaveUpDown_name, measureBar_name)
	local newGrouptRef = nil
	local length = self:get_melodyLength(melodyLength_name).val
	local octaveUpDown = self:get_octaveUpDown(octaveUpDown_name).val
	local measureBar = self:get_measureBar(measureBar_name).val
	
	local melody = self:generate_melody(root_note, scale_type, style_name, rhythm_name, 
		length, octaveUpDown, measureBar)
	
	if #self.errorMessages > 0 then
		self:addTextPanel(self:displayErrors())
		self:show("Error:" .. "\r" .. self:displayErrors())
	else
		self.currentSeconds = SV:getPlayback():getPlayhead()
		local checkGroup = self:getGroupRef(self:getCurrentTrack(), self.currentSeconds)
		if checkGroup ~= nil then
			self.currentSeconds = self:getNextEmptyPosition(self:getCurrentTrack(), checkGroup:getEnd())
			SV:getPlayback():seek(self.currentSeconds)
		else
			local newPositionBlicks = self:getTimeAxis():getBlickFromSeconds(self.currentSeconds)
			measureBlick = self:getFirstMesure(newPositionBlicks, 0)
			self.currentSeconds = self:getTimeAxis():getSecondsFromBlick(measureBlick)
			SV:getPlayback():seek(self.currentSeconds)
		end

		newGrouptRef = self:createGroup(self.currentSeconds, self:getCurrentTrack(), melody)
		
		if newGrouptRef ~= nil then
			self:displayMessage(SV:T("Group created!"))
						
			self.currentPlayheadSeconds = SV:getPlayback():getPlayhead()
			-- Update currentSeconds to next position
			self.beginGroup = newGrouptRef:getOnset()
			self.endGroup = newGrouptRef:getEnd()
			
			-- playBack option
			if self.controls.autoPlay.value:getValue() then
				local startPosSeconds = self:getTimeAxis():getSecondsFromBlick(self.beginGroup)
				local endPosSeconds = self:getTimeAxis():getSecondsFromBlick(self.endGroup)
				SV:getPlayback():seek(startPosSeconds)
				if self.controls.loopAutoPlay.value:getValue()then
					SV:getPlayback():loop(startPosSeconds, endPosSeconds)
				end
				SV:getPlayback():play()
			else
				if SV:getPlayback():getStatus() == "playing" or SV:getPlayback():getStatus() == "looping" then
					SV:getPlayback():stop()
				end
			end
		else
			local errorMessage = SV:T("Error: Empty group, nothing created!")
			self:error(errorMessage)
			self:show(errorMessage)
		end
	end
	return newGrouptRef
end

-- Get next empty position on track
function NotesObject:getNextEmptyPosition(currentTrack, lastPositionBlicks)
	local measureBlick = self:getFirstMesure(lastPositionBlicks, 1)
	local seconds = self:getTimeAxis():getSecondsFromBlick(measureBlick)
	local checkGroup = self:getGroupRef(currentTrack, seconds)
	
	if checkGroup ~= nil then
		-- A group is found there
		-- Next measure bar
		measureBlick = self:getFirstMesure(checkGroup:getEnd(), 1)
		-- Recursive check to get empty place in track
		seconds = self:getNextEmptyPosition(currentTrack, measureBlick)
	end
	 
	return seconds
end

-- Get combo box data
function NotesObject:getComboLists()
	self.scalesList = {}
	self.stylesList = {}
	self.rhythmsList = {}
	self.melodyLengthList = {}
	self.octaveUpDownList = {}
	self.measureBarList = {}
	
	-- scales list
	for key, v in ipairs(self.scales) do
		table.insert(self.scalesList, self.scales[key].name)
	end
	-- styles list
	for key, v in ipairs(self.styles) do
		table.insert(self.stylesList, self.styles[key].name)
	end
	-- rhythms list
	for key, v in ipairs(self.rhythms) do
		table.insert(self.rhythmsList, self.rhythms[key].name)
	end
	-- melody length list and data
	for key, v in ipairs(self.melodyLength) do
		table.insert(self.melodyLengthList, self.melodyLength[key].name)
	end
	-- octave up or down list and data
	for key, v in ipairs(self.octaveUpDown) do
		table.insert(self.octaveUpDownList, self.octaveUpDown[key].name)
	end
	-- measure bar list and data
	for key, v in ipairs(self.measureBar) do
		table.insert(self.measureBarList, self.measureBar[key].name)
	end
end

-- Get section
function NotesObject:getSection()
	-- Define all ComboBox	
	self:setComboChoices()

	-- Define CheckBox & button & textarea
	local section = {
		title = SV:T(SCRIPT_TITLE),
		rows = {
			{
				type = "Label",
				text = SV:T("Select a key scale:"),
			},
			self.keyScaleChoice,
			self.styleChoice,
			self.melodyLengthChoice,
			{
				type = "Container",
				columns = {
					{
					type = "CheckBox",
					text = SV:T("Auto play melody"),
					value = self.controls.autoPlay.value,
					width = 1.0
					}
				}
			},
			{
				type = "Container",
				columns = {
					{
					type = "CheckBox",
					text = SV:T("Loop into melody"),
					value = self.controls.loopAutoPlay.value,
					width = 1.0
					}
				}
			},
			self.measureBarChoice,
			{
				type = "Container",
				columns = {
					{
						type = "Button",
						text = SV:T("Apply"),
						width = 1.0,
						value = self.applyButtonValue
					}
				}
			},
			{
				type = "Container",
				columns = {
					{
						type = "TextArea",
						value = self.statusTextValue,
						height = 40,
						width = 1.0,
						readOnly = true
					}
				}
			}
		}
	}
	return section
end

-- Set ComboBox choices
function NotesObject:setComboChoices()
	-- Define ComboBox	
	
	self.keyScaleChoice = {
		type = "Container",
		columns = {
			{
				type = "ComboBox",
				text = SV:T("Select a key scale"),
				value = self.controls.scaleKey.value,
				choices = self.keyNames,
				width = 0.3
			},
			{
				type = "ComboBox",
				text = SV:T("Select a scale type"),
				value = self.controls.scaleType.value,
				choices = self.scalesList,
				width = 0.7
			}
		}
	}
	
	self.styleChoice = {
        type = "Container",
        columns = {
			{
				type = "ComboBox",
				text = SV:T("Select a style"),
				value = self.controls.style.value,
				choices = self.stylesList,
				width = 0.4
			},
			{
				type = "ComboBox",
				text = SV:T("Select a rhythm"),
				value = self.controls.rhythm.value,
				choices = self.rhythmsList,
				width = 0.6
			}
        }
    }
	
	self.melodyLengthChoice = {
        type = "Container",
        columns = {
			{
				type = "ComboBox",
				text = SV:T("Select melody length"),
				value = self.controls.melodyLength.value,
				choices = self.melodyLengthList,
				width = 0.5
			},
			{
				type = "ComboBox",
				text = SV:T("Select octave (down:-1, base:0, up:+1)"),
				value = self.controls.octaveUpDown.value,
				choices = self.octaveUpDownList,
				width = 0.5
			}
        }
    }

	self.measureBarChoice = {
        type = "Container",
        columns = {
			{
				type = "ComboBox",
				text = SV:T("Note position to measure bar"),
				value = self.controls.measureBar.value,
				choices = self.measureBarList,
				width = 1.0
			}
        }
    }
	
end

-- Create a melody
function NotesObject:createMelody(scaleKey, scale, style, rhythm, melodyLength, octaveUpDown, measureBarChoice)
	-- Combo box item start to 0 => +1 for data
	local scaleKeyOutput = scaleKey + 1
	local scaleOutput = scale + 1 
	local styleOutput = style + 1
	local rhythmsOutput = rhythm + 1
	local melodyLengthOutput = melodyLength + 1
	local octaveUpDownOutput = octaveUpDown + 1
	local measureBarChoiceOutput = measureBarChoice + 1

	-- Get keys values
	local scaleKey = self.keyNames[scaleKeyOutput]
	local scaleChoice = self.scalesList[scaleOutput]
	local styleChoice = self.stylesList[styleOutput]
	local rhythmChoice = self.rhythmsList[rhythmsOutput]
	local melodylengthChoice = self.melodyLengthList[melodyLengthOutput]
	local octaveUpDownChoice = self.octaveUpDownList[octaveUpDownOutput]
	local measureBarChoice = self.measureBarList[measureBarChoiceOutput]
	
	-- Generate a melody in a new group
	local newGrouptRef = self:generateGroup(scaleKey, scaleChoice, styleChoice, 
						rhythmChoice, melodylengthChoice, octaveUpDownChoice, measureBarChoice)
	
	if newGrouptRef ~= nil then
		SV:getArrangement():getSelection():selectGroup(newGrouptRef)
		SV:getMainEditor():getSelection():selectGroup(newGrouptRef)
	end
end

-- Get panel section state
function NotesObject:getPanelSectionState()

	self.applyButtonValue:setEnabled(true)
	local errors = self:displayErrors()
	if #errors > 0 then
		self:addTextPanel(errors)
	end
	
	-- Get section data
	local section = self:getSection()

	return section
end

-- Initialize main internal object	
local notesObject = NotesObject:new()

-- Get panel section state called by Synthesizer V internal system
function getSidePanelSectionState()

	local section = notesObject:getPanelSectionState()

	return section
end
