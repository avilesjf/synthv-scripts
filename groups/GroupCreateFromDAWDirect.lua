local SCRIPT_TITLE = 'Group create direct from DAW V1.2'

--[[

Synthesizer V Studio Pro Script
 
lua file name: GroupCreateFromDAWDirect.lua

Version for Synthesizer V version >= 2.1.1

Drag and drop notes from DAW: Automate group creation
1/ Waiting any newly created track
2/ Move imported DAW notes into a new group of notes
Version with NO dialog box

Note: Stopping this script:
A/ If you want to STOP this script without the required drag&drop DAW (multiple options): 
	A- STOP this script by creating a new note on the piano roll
	B- STOP this script by selecting a new existing note
	C- STOP this script by running this script again! 
		(hidden group used for this feature)

Update: 0 - Minor updates
		6 - Add multiple group creation after dropping chords notes from DAW
		
2025 - JF AVILES
--]]

-- Generated by JFA TranslateScripts.lua
function getTranslations(langCode)
	return getArrayLanguageStrings()[langCode]
end

-- Generated by JFA TranslateScripts.lua
function getArrayLanguageStrings()
	return {
		["en-us"] = {
			{"Track", "Track"},
			{"Waiting: ", "Waiting: "},
			{"Error nil value with param: ", "Error nil value with param: "},
			{"Error in saved parameters, try again!", "Error in saved parameters, try again!"},
		},
	}
end

function getClientInfo()
	return {
		name = SV:T(SCRIPT_TITLE),
		category = "_JFA_Groups",
		author = "JFAVILES",
		versionNumber = 6,
		minEditorVersion = 65540
	}
end

-- Define a class  "NotesObject"
NotesObject = {
	project = nil,
	timeAxis = nil,
	editor = nil,
	THRESHOLD = 41505882,  -- 0.03 seconds (120)
	INITIAL_TRACK_NAME_REF = "initialTrackName",
	NUM_TRACKS_REF = "numTracks",
	CURRENT_TRACK_REF = "currentTrack",
	GROUP_TAG = "GroupData:",
	GROUP_STOP_TAG = "GroupStop:",
	LINK_NOTES_ACTIVE = "linkNotesActive",
	TRACK_TARGET_REF = "trackTarget",
	groupStoredRefFound = nil,
	groupStoredFound = nil,
	groupStoredRefToStopPrevious = nil,
	groupStoredToStopPrevious = nil,
	linkNotesActive = true,
	trackTarget = nil,
	initialTrackName = "",
	scriptInstance = "",
	newDAWTrack = nil,
	newGrouptRef = nil,
	currentTrack = nil,
	numTracks = 0,
	selection = nil,
	selectedNotes = nil,
	numSelectedNotes = 0,
	playBack = nil,
	currentSeconds = 0,
	stopProcess = false,
	stopProcessOK = false,
	processing = 0,
	isTrackClone = true, -- clone current track voice
	colors = {},
	currentColorPos = 0,
	currentColor = "",
	sepParam = "|",
	lyricsException = {}
}

-- Constructor method for the NotesObject class
function NotesObject:new()
    local notesObject = {}
    setmetatable(notesObject, self)
    self.__index = self
	
    self.project = SV:getProject()
    self.timeAxis = self.project:getTimeAxis()
    self.editor =  SV:getMainEditor()
	self.numTracks = self.project:getNumTracks()
	
	self.selection = self.editor:getSelection()
	self.selectedNotes = self.selection:getSelectedNotes()
	self.numSelectedNotes = #self.selection:getSelectedNotes()
	
	self.playBack = SV:getPlayback()
	self.currentSeconds = self.playBack:getPlayhead()
	self.currentTrack = self.editor:getCurrentTrack()
	self.initialTrackName = self.currentTrack:getName()
	self.trackTarget = self.currentTrack
	self.colors = self:getColors()
	self.lyricsException = {"+", "++", "-", "br", "'", ".cl", ".pau", ".sil"}

    return self
end

-- Get track notes count
function NotesObject:getTrackNumNotes(track)
	local numNotes = 0
	for iGroupNote = 1, track:getNumGroups() do
		local groupRef = track:getGroupReference(iGroupNote)
		local group = groupRef:getTarget()
		numNotes = numNotes + group:getNumNotes()
	end
	return numNotes
end

--- Get last created track
function NotesObject:getLastTrack()
	return self.project:getTrack(self.project:getNumTracks())
end

-- Display message box
function NotesObject:show(message)
	SV:showMessageBox(SV:T(SCRIPT_TITLE), message)
end

-- Get time max gap between notes
function NotesObject:getMaxTimeGapFromBPM(positionSeconds)
	local THRESHOLDBlicks = self.THRESHOLD
	local coef = 17 -- Convert 1/quarterBlicks to 0.03 seconds (120)
	local bpm = self:getProjectTempo(positionSeconds)
	
	if bpm ~= nil then
		-- "120:" time: 0.03s, 1s: blicks 1411200000 quarter 2
		-- "60: " time: 0.06s, 1s: blicks 705600000 quarter 1
		local blicks = SV:seconds2Blick(1, bpm) -- get blicks 1 second with bpm
		local quarterBlicks = SV:blick2Quarter(blicks)
		local gapMax = (1/quarterBlicks) / coef  -- result gap in seconds
		THRESHOLDBlicks = self.timeAxis:getBlickFromSeconds(gapMax)
	end
	return THRESHOLDBlicks
end

-- Get current project tempo
function NotesObject:getProjectTempo(seconds)
	local tempoActive = 120
	local blicks = self.timeAxis:getBlickFromSeconds(seconds)
	local tempoMarks = self.timeAxis:getAllTempoMarks()
	for iTempo = 1, #tempoMarks do
		local tempoMark = tempoMarks[iTempo]
		if tempoMark ~= nil and blicks >= tempoMark.position then
			tempoActive = tempoMark.bpm
		end
	end
	return math.floor(tempoActive)
end

-- Get string format from seconds
function NotesObject:secondsToClock(timestamp)
	return string.format("%02d:%06.3f", 
	  --math.floor(timestamp/3600), 
	  math.floor(timestamp/60)%60, 
	  timestamp%60):gsub("%.",",")
end

-- Get new color
function NotesObject:getNewColor(track)
	if self.currentColorPos == 0 then 
		self.currentColorPos = self:getCurrentColorPos(track)
	end
	self.currentColorPos = self.currentColorPos + 1
	if self.currentColorPos > #self.colors then
		self.currentColorPos = 1
	end
	return self.colors[self.currentColorPos].val
end

-- Get current color position
function NotesObject:getCurrentColorPos(track)
	local newPos = 1
	for i, color in ipairs(self.colors) do
		if color.val == track:getDisplayColor() then
			newPos = i
			break
		end
	end	
	return newPos
end

-- Get colors
function NotesObject:getColors()
	local colors = {}
	table.insert(colors, {val = "ffd14f5b", name = "red"})
	table.insert(colors, {val = "ffc27455", name = "orange"})
	table.insert(colors, {val = "ffc27455", name = "ocher"})
	table.insert(colors, {val = "ffd6bc43", name = "yellow"})
	table.insert(colors, {val = "ff7db235", name = "green"})
	table.insert(colors, {val = "ff3bb26c", name = "greenish"})
	table.insert(colors, {val = "ff3eb2a8", name = "blue-sky"})
	table.insert(colors, {val = "ff4794cb", name = "blue"})
	table.insert(colors, {val = "ff5478c7", name = "turquoise"})
	table.insert(colors, {val = "ff6959d4", name = "purple"})
	table.insert(colors, {val = "ffb853b3", name = "pink"})
	return colors
end

-- Get first mesure before first note
function NotesObject:getFirstMesure(notePos)
	local measurePos = 0
	local measureBlick = 0
	local measureFirst = self.timeAxis:getMeasureAt(notePos)
	local checkExistingMeasureMark = self.timeAxis:getMeasureMarkAt(measureFirst)
	
	if checkExistingMeasureMark ~= nil then
		if checkExistingMeasureMark.position == measureFirst then
			measurePos = checkExistingMeasureMark.position
			measureBlick = checkExistingMeasureMark.positionBlick
		else 
			self.timeAxis:addMeasureMark(measureFirst, 
						checkExistingMeasureMark.numerator, 
						checkExistingMeasureMark.denominator)
			local measureMark = self.timeAxis:getMeasureMarkAt(measureFirst)
			measurePos = measureMark.position
			measureBlick = measureMark.positionBlick
			self.timeAxis:removeMeasureMark(measureFirst)
		end
	else
		-- Temporary measure mark addition
		self.timeAxis:addMeasureMark(measureFirst, 4, 4)
		local measureMark = self.timeAxis:getMeasureMarkAt(measureFirst)
		measurePos = measureMark.position
		measureBlick = measureMark.positionBlick
		self.timeAxis:removeMeasureMark(measureFirst)
	end
	return measureBlick
end

-- Remove track DAW
function NotesObject:removeTrackDAW()
	if self.newDAWTrack ~= nil then
		self.project:removeTrack(self.newDAWTrack:getIndexInParent())
		self.newDAWTrack = nil
	end
end

-- Clone track to keep current track voice
function NotesObject:cloneTrackReference(trackRef, trackName)
	local newTrack = trackRef:clone()		
	local iGroups = newTrack:getNumGroups()
	local color = self:getNewColor(self.trackTarget)
	newTrack:setDisplayColor(color)
	
	if iGroups > 1 then
		-- Delete groups
		while iGroups > 1 do
			local groupRef = newTrack:getGroupReference(iGroups)
			local index = groupRef:getIndexInParent()
			if groupRef ~= nil and not groupRef:isMain() then
				newTrack:removeGroupReference(index)
				iGroups = newTrack:getNumGroups()
			end
		end
	end
	
	newTrack:setName(trackName)
	self.project:addTrack(newTrack)

	return newTrack
end

-- Create track target
function NotesObject:createTrackTarget(name)
	local newTrackTarget = SV:create("Track")
	local color = self:getNewColor(self.trackTarget)
	newTrackTarget:setDisplayColor(color)
	
	local newTrackIndex = self.project:addTrack(newTrackTarget)
	newTrackTarget = self.project:getTrack(newTrackIndex)
	newTrackTarget:setName(name)
	return newTrackTarget
end

-- Create group for new track with new notes
function NotesObject:createGroup(startPosition, targetPosition)
	local maxLengthResult = 30
	local groupRefMain = self.newDAWTrack:getGroupReference(self.newDAWTrack:getNumGroups())
	local durationGroupRefMain = groupRefMain:getDuration()
	local groupNotesMain = groupRefMain:getTarget()
	local isChordsGroup = false
	
	local mainGroupNotes = {}
	
	local iGroup = 1
	self.THRESHOLD = self:getMaxTimeGapFromBPM(targetPosition) -- 41505882 = 0.06 seconds
	local previousNote = nil

	-- Save notes to groups
	for iNote = 1, groupNotesMain:getNumNotes() do
		local note = groupNotesMain:getNote(iNote)
		if previousNote ~= nil then
			if note:getOnset() == previousNote:getOnset() then
				isChordsGroup = true
				iGroup = iGroup + 1
			else
				iGroup = 1
			end
		end
		if mainGroupNotes[iGroup] == nil then
			mainGroupNotes[iGroup] = {}
		end
		table.insert(mainGroupNotes[iGroup], note)
		previousNote = groupNotesMain:getNote(iNote)
	end
	
	if #mainGroupNotes > 0 then
		for iGroup, group in ipairs(mainGroupNotes) do
			-- Create new group 
			local noteGroup = SV:create("NoteGroup")
			local newGrouptRef = SV:create("NoteGroupReference")
				
			self.project:addNoteGroup(noteGroup)
			newGrouptRef:setTarget(noteGroup)
			newGrouptRef:setTimeOffset(startPosition)
			newGrouptRef:setTimeRange(startPosition, durationGroupRefMain) -- v2.1.1
			
			if iGroup == 1 then
				self.currentTrack:addGroupReference(newGrouptRef)
			else
				local trackName = self.initialTrackName .. "-" .. iGroup
				if self.isTrackClone then
					-- Clone track for new groups
					local track = self:cloneTrackReference(self.currentTrack, trackName)
					track:addGroupReference(newGrouptRef)
				else
					local track = self:createTrackTarget(trackName)
					track:addGroupReference(newGrouptRef)
				end
			end

			local previousNote = nil
			for iNote = 1, #group do
				local note = group[iNote]:clone()
				-- Update position within the new group
				note:setOnset(group[iNote]:getOnset())
				
				if self.linkNotesActive then
					if previousNote ~= nil then
						self:linkedTheNotes(previousNote, note, noteGroup:getNote(iNote - 1))
					end
				end
				
				noteGroup:addNote(note)
				previousNote = note
			end
			
			local resultLyrics = self:renameOneGroup(self.timeAxis, maxLengthResult, noteGroup)
		end
	end
	
	return true
end

-- Linked the notes
function NotesObject:linkedTheNotes(previousNote, note, storedNote)
	local gapNotes = previousNote:getEnd() - note:getOnset()
	-- SIL = 29400000 => 0.02s
	-- if iNote == 2 then 
		-- self:show("gapNotes: " .. gapNotes .. ", " 
		-- .. self.timeAxis:getSecondsFromBlick(gapNotes))
	-- end
	
	-- Notes overlay
	if gapNotes > 0 then
	-- if previousNote:getEnd() > note:getOnset() then
		-- Reduce previous note duration
		storedNote:setDuration(previousNote:getDuration() - gapNotes)
	end
				
	-- SIL = short time between notes
	if gapNotes < 0 and math.abs(gapNotes) < self.THRESHOLD then
		-- Spread previous note duration
		storedNote:setDuration(previousNote:getDuration() + math.abs(gapNotes))
	end
end

-- Rename one group
function NotesObject:renameOneGroup(timeAxis, maxLengthResult, noteGroup)
	local resultLyrics = ""
	local groupName = noteGroup:getName()
	local notesCount = noteGroup:getNumNotes()

	if notesCount > 0 then
		local lyricsLine = ""
		local sep = ""

		for i = 1, notesCount do
			local infos = ""
			local note = noteGroup:getNote(i)
			
			if note ~= nil then
				local lyrics = note:getLyrics()
				if string.len(lyrics) > 0 then
				
					-- Filter char '+' & '-' & 'br' & .cl & .pau & .sil
					if self:isTextAccepted(timeAxis, note) then
						-- Replace following note char '-'
						if lyrics == "-" then lyrics = ".." end 
						-- Add lyrics for each note
						lyricsLine = lyricsLine .. sep .. lyrics
						sep = " "
					end				  
				end
			end
		end

		-- Add lyrics
		resultLyrics = self:limitStringLength(lyricsLine, maxLengthResult)
		-- Update if new lyrics only
				if string.len(resultLyrics)> 0 and
			noteGroup:getName() ~= resultLyrics then
			noteGroup:setName(resultLyrics)
		end
	end

	return resultLyrics
end

-- Limit string max length
function NotesObject:limitStringLength(resultLyrics, maxLengthResult)
	-- Limit string max length
	if string.len(resultLyrics) > maxLengthResult then
		local posStringChar = string.find(resultLyrics," ", maxLengthResult - 10)
		if posStringChar == nil then posStringChar = maxLengthResult end
		resultLyrics = string.sub(resultLyrics, 1, posStringChar)
	end
	return resultLyrics
end

-- Check lyrics "a" less than .1s for special effect
function NotesObject:isLyricsEffect(timeAxis, note)
	local result = false
	local notelength = timeAxis:getSecondsFromBlick(note:getDuration())
	-- ie: 0.0635
	if notelength < 0.1 then
		result = true
	end
	return result
end

-- Is lyrics is a text accepted new
function NotesObject:isTextAcceptedNew(lyrics)
	local result = true
	
	-- Filter char '+' & '++' & '-' & 'br' & .cl & .pau & .sil
	for i, lyricsExcept in pairs(self.lyricsException) do
		if  lyrics == lyricsExcept then
			result = false
			break
		end
	end

	return result
end

-- Is lyrics is a text accepted
function NotesObject:isTextAccepted(timeAxis, note)
	local result = false
	local lyrics = note:getLyrics()
	
	if self:isTextAcceptedNew(lyrics) then
		result = true
	end
	
	-- Specific for personal vocal effect
	if lyrics == "a" and self:isLyricsEffect(timeAxis, note) then
		result = false
	end

	return result
end

-- Set track name waiting
function NotesObject:setTrackNameWaiting()
	if self.trackTarget ~= nil then
		self.processing = self.processing  + 1
		if self.processing > 4 then
			self.processing = 0
		end
		local followString = string.rep(".", self.processing)
		local targetName = followString .. " " .. self.initialTrackName
		self.trackTarget:setName(targetName)
	end
end

-- Create group for internal data
function NotesObject:createInternalGroup()
	-- Create new group 
	local noteGroup = SV:create("NoteGroup")
	self.project:addNoteGroup(noteGroup)
	
	local newGrouptRef = SV:create("NoteGroupReference", noteGroup)
	
	return newGrouptRef, noteGroup
end

-- Set new group name with data
function NotesObject:setNewGroupName(noteGroup, GROUP_TAG, data)
	noteGroup:setName(GROUP_TAG .. "\r" .. data)
end

-- Get previous stored data group
function NotesObject:getPreviousStoredGroup(GROUP_TAG)
	local groupStoredRefFound = nil
	local groupStoredFound = nil
	
	for iNoteGroup = 1, self.project:getNumNoteGroupsInLibrary() do
		local group = self.project:getNoteGroup(iNoteGroup)
		if group ~= nil then
			local groupRef = group:getParent()
			if groupRef ~= nil then
				local groupName = group:getName()
				local pos = string.find(groupName, GROUP_TAG)
				if pos ~= nil then 
					groupStoredRefFound = groupRef
					groupStoredFound = group
					break
				end
			end
		end
	end
	return groupStoredRefFound, groupStoredFound
end

-- Get data content
function NotesObject:getGroupContentData(data)
	local pos = string.find(data, self.GROUP_TAG)
	if pos ~= nil then
		data = string.sub(data, pos + string.len(self.GROUP_TAG) + 1)
	end
	return data
end

-- Get group reference in time position
function NotesObject:getGroupRef(track, time)
	local groupRefFound = nil
	local numGroups = track:getNumGroups()
	local blicksPos = self.timeAxis:getBlickFromSeconds(time)
	
	-- All groups except the main group
	for iGroup = 2, numGroups do
		local groupRef = track:getGroupReference(iGroup)
		if not groupRef:isInstrumental() then
			local blickSeconds = self:secondsToClock(self.timeAxis:getSecondsFromBlick(groupRef:getOnset()))
			
			-- Get group on timing pos
			if blicksPos >= groupRef:getOnset() and blicksPos <= groupRef:getEnd() then
				groupRefFound = groupRef
				break
			end
		end						
	end						
	return groupRefFound
end

-- Main loop
function NotesObject:loop()
	local newSelectedNotes = #self.selection:getSelectedNotes()
	local cause = ""

	self.groupStoredRefToStopPrevious, self.groupStoredToStopPrevious = 
		self:getPreviousStoredGroup(self.GROUP_STOP_TAG)

	if self.groupStoredToStopPrevious ~= nil then
		self.stopProcess = true
	end
	
	if self.numSelectedNotes ~= newSelectedNotes then
		cause = "Selected notes: " .. self.numSelectedNotes .. "/" .. newSelectedNotes
		self.stopProcess = true
	end
	
	if self.stopProcess then
		-- self:show("cause: " .. cause)
		self:endOfScript()
	else
		-- if a new same script instance is running or track is deleted by another script
		if self.numTracks > self.project:getNumTracks() then
			self.stopProcess = true
			self:endOfScript()
		else
			-- Scan a new track
			self:scanNewTrack()
			
			if not self.stopProcess then
				SV:setTimeout(500, function() self:loop() end)
			else
				self:endOfScript()
			end
		end
	end	
end

-- Scan a new track
function NotesObject:scanNewTrack()
	SV:setTimeout(200, function() self:setTrackNameWaiting() end)
	self.currentSeconds = self.playBack:getPlayhead()
	local secondsInfo = self:secondsToClock(self.currentSeconds)
	
	-- Check if a new track is created
	if self.numTracks < self.project:getNumTracks() then
		self.newDAWTrack = self:getLastTrack()
		local numNotesNewDAWTrack = self:getTrackNumNotes(self.newDAWTrack)
		
		if numNotesNewDAWTrack > 0 then
			
			local newStartPosition = self.timeAxis:getBlickFromSeconds(self.currentSeconds)
			local measureBlick = self:getFirstMesure(newStartPosition)

			-- New notes => Create a new group
			self:createGroup(measureBlick, self.currentSeconds)
			self:removeTrackDAW()
			self.stopProcess = true -- End of process
			self.stopProcessOK = true -- End of process OK
			self:setTrackTarget()
		else
			-- a new track is created with no notes
		end
	end
end

-- Stop script 
function NotesObject:stopScript()
		self.stopProcess = true
		SV:finish()
end

-- Set track target
function NotesObject:setTrackTarget()
	if self.trackTarget ~= nil then
		self.trackTarget:setName(self.initialTrackName)
	end
end

-- Stop script 
function NotesObject:stopScript()
		self.stopProcess = true
		SV:setTimeout(30, function() self:finishScriptProcess() end)
end

-- Delete stop stored group
function NotesObject:deleteStopStoredGroup()

	if self.groupStoredToStopPrevious ~= nil then
		local groupIndex = self.groupStoredToStopPrevious:getIndexInParent()
		self.project:removeNoteGroup(groupIndex)
		self.groupStoredRefToStopPrevious = nil
		self.groupStoredToStopPrevious = nil
	end
end

-- Delete previous stored group
function NotesObject:deletePreviousStoredGroup()

	if self.groupStoredFound ~= nil then
		local groupIndex = self.groupStoredFound:getIndexInParent()
		self.project:removeNoteGroup(groupIndex)
		self.groupStoredRefFound = nil
		self.groupStoredFound = nil
	end
end

-- End of script 
function NotesObject:endOfScript()
	self.stopProcess = true
	self:setTrackTarget()

	-- clean previous data
	SV:setTimeout(10, function() self:deletePreviousStoredGroup() end)	
	SV:setTimeout(20, function() self:deleteStopStoredGroup() end)
	SV:setTimeout(30, function() self:finishScriptProcess() end)
end

-- Finish script processing
function NotesObject:finishScriptProcess()	
	-- End of script
	SV:finish()
end

-- trim string
function NotesObject:trim(s)
	  return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
end

-- Get stored data 
function NotesObject:getStoredData()
	local result = false
	
	-- self.GROUP_TAG .. self.sepParam .. |initialTrackName=Track 1
	local groupData = self:getGroupContentData(self.groupStoredFound:getName())

	if self:isParametersOk(groupData) then

		local paramSlitted = self:split(groupData, self.sepParam)
		for iLine = 1, #paramSlitted do
			local param = paramSlitted[iLine]
			local paramArray = self:split(param, "=")
			local paramKey = ""
			local paramValue = ""
			
			if paramArray[1] ~= nil then
				paramKey = self:trim(paramArray[1])
			-- else
				-- self:show(SV:T("Error nil value with param: ") .. param)
			end
			
			if paramArray[2] ~= nil then
				paramValue = self:trim(paramArray[2])
			-- else
				-- self:show(SV:T("Error nil value with param: ") .. param)
			end
			self:setParametersFromStoredGroup(paramKey, paramValue)
		end		
		result = true
	end

	return result
end

-- Check if parameters OK
function NotesObject:isParametersOk(data)
	local result = false
	if data ~= nil then
		if type(data) == "string" then
			if string.find(data, self.INITIAL_TRACK_NAME_REF) ~= nil then
				result = true
			end
		end
	end
	return result
end

-- Set parameters from stored hidden group
function NotesObject:setParametersFromStoredGroup(paramName, value)
	if string.find(paramName, self.INITIAL_TRACK_NAME_REF) then
		self.initialTrackName = value
	end
	if string.find(paramName, self.NUM_TRACKS_REF) then
		self.numTracks = tonumber(value)
	end	
	if string.find(paramName, self.TRACK_TARGET_REF) then
		local iTrack = tonumber(value)
		if iTrack <= self.numTracks then
			self.trackTarget = self.project:getTrack(iTrack)
		else
			self:show(SV:T("Error in saved parameters, try again!"))
			self:stopScript()
		end
	end
	if string.find(paramName,self.CURRENT_TRACK_REF) then
		local iTrack = tonumber(value)
		if iTrack <= self.numTracks then
			self.currentTrack = self.project:getTrack(iTrack)
		else
			self:show(SV:T("Error in saved parameters, try again!"))
			self:stopScript()
		end
	end
	if string.find(paramName, self.LINK_NOTES_ACTIVE) then
		self.linkNotesActive = false
		if value == "true" then 
			self.linkNotesActive = true
		end
	end

end

-- Split string by sep char
function NotesObject:split(str, sep)
   local result = {}
   local regex = ("([^%s]+)"):format(sep)
   for each in str:gmatch(regex) do
	  table.insert(result, each)
   end
   return result
end

-- Store data to hidden group
function NotesObject:storeToHiddenGroup()
	
	if self.groupStoredFound == nil then
		self.groupStoredRefFound, self.groupStoredFound = self:createInternalGroup()
		local data = self.INITIAL_TRACK_NAME_REF	.. "=" .. self.initialTrackName					.. self.sepParam
			.. self.LINK_NOTES_ACTIVE				.. "=" .. tostring(self.linkNotesActive)		.. self.sepParam
			.. self.NUM_TRACKS_REF					.. "=" .. self.numTracks						.. self.sepParam
			.. self.TRACK_TARGET_REF				.. "=" .. self.trackTarget:getIndexInParent()	.. self.sepParam
			.. self.CURRENT_TRACK_REF				.. "=" .. self.currentTrack:getIndexInParent()
		self:setNewGroupName(self.groupStoredFound, self.GROUP_TAG, data)

		-- Get this stored data
		self:getStoredData()
	end
end

-- Create groups to stop process
function NotesObject:groupToStopProcess()
	self.groupStoredRefToStopPrevious, self.groupStoredToStopPrevious = self:createInternalGroup()
	self:setNewGroupName(self.groupStoredFound, self.GROUP_STOP_TAG, "STOP")
end

-- Start process
function NotesObject:startProcess()
	self.groupStoredRefFound, self.groupStoredFound = self:getPreviousStoredGroup(self.GROUP_TAG)
	
	-- Is first script processing
	if self.groupStoredFound == nil then
		-- self:getProject():newUndoRecord()
		self:storeToHiddenGroup()
		SV:setTimeout(100, function() self:loop() end)
	else
		local result = self:getStoredData()
		self:groupToStopProcess()
		SV:setTimeout(100, function() self:endOfScript() end)
		
	end
end

-- Main processing task	
function main()
	local notesObject = NotesObject:new()
	notesObject:startProcess()
end

