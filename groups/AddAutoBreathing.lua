local SCRIPT_TITLE = 'Add automatic breathing'

--[[

lua file name: AddAutoBreathing.lua

Automatic Breath Management
For all groups in track or limited to selected groups

Update: 1 - Creation

2025 - JF AVILES
--]]

function getClientInfo()
	return {
		name = SV:T(SCRIPT_TITLE),
		category = "_JFA_Groups",
		author = "JFAVILES",
		versionNumber = 1,
		minEditorVersion = 65540
	}
end

-- Generated by JFA TranslateScripts.lua
function getTranslations(langCode)
	return getArrayLanguageStrings()[langCode]
end

-- Generated by JFA TranslateScripts.lua
function getArrayLanguageStrings()
	return {
		["en-us"] = {
			{"%d breath(s) added to track '%s'", "%d breath(s) added to track '%s'"},
			{"Insert automatic breaths in current track (all groups)?", "Insert automatic breaths in current track (all groups)?"},
			{"No groups selected", "No groups selected"},
			{"Cancel => to abort", "Cancel => to abort"},
			{"No => limit to selected groups: ", "No => limit to selected groups: "},
			{"%d breath(s) added to groups selected: ", "%d breath(s) added to groups selected: "},
			{"No sufficient gaps found between notes in selected groups:", "No sufficient gaps found between notes in selected groups:"},
		},
	}
end

-- Define a class  "NotesObject"
NotesObject = {
	project = nil,
	timeAxis = nil,
	editor = nil,
	currentTrack = nil,
	BREATH_DURATION = 0,	-- Breath duration in blicks updated by getMaxTimeGapFromBPM
	MIN_GAP_FOR_BREATH = 0,	-- Minimum gap required to insert a breath updated by getMaxTimeGapFromBPM
	BREATH_PHONEME = "br"	-- Breath phoneme (may vary depending on voice bank)
}

-- Constructor method for the NotesObject class
function NotesObject:new()
    local notesObject = {}
    setmetatable(notesObject, self)
    self.__index = self
	
    self.project = SV:getProject()
    self.timeAxis = self.project:getTimeAxis()
    self.editor =  SV:getMainEditor()
	
	self.currentTrack = self.editor:getCurrentTrack()
	
    return self
end

-- Display message box
function NotesObject:show(message)
	SV:showMessageBox(SV:T(SCRIPT_TITLE), message)
end

-- Get time max gap between notes
function NotesObject:getMaxTimeGapFromBPM(positionSeconds)
	local THRESHOLDBlicks = self.THRESHOLD
	local coef = 17 -- Convert 1/quarterBlicks to 0.03 seconds (120)
	local bpm = self:getProjectTempo(positionSeconds)
	
	if bpm ~= nil then
		-- "120:" time: 0.03s, 1s: blicks 1411200000 quarter 2
		-- "60: " time: 0.06s, 1s: blicks 705600000 quarter 1
		local blicks = SV:seconds2Blick(1, bpm) -- get blicks 1 second with bpm
		local quarterBlicks = SV:blick2Quarter(blicks)
		local gapMax = (1/quarterBlicks) / coef  -- result gap in seconds
		THRESHOLDBlicks = self.timeAxis:getBlickFromSeconds(gapMax)
	end
	return THRESHOLDBlicks
end

-- Get current project tempo
function NotesObject:getProjectTempo(seconds)
	local tempoActive = 120
	local blicks = self.timeAxis:getBlickFromSeconds(seconds)
	local tempoMarks = self.timeAxis:getAllTempoMarks()
	for iTempo = 1, #tempoMarks do
		local tempoMark = tempoMarks[iTempo]
		if tempoMark ~= nil and blicks >= tempoMark.position then
			tempoActive = tempoMark.bpm
		end
	end
	return math.floor(tempoActive)
end

-- Process a complete track
function NotesObject:processTrack(track)
	local breathsInserted = 0
	
	for iGroupNote = 1, track:getNumGroups() do
		local groupRef = track:getGroupReference(iGroupNote)
		local noteGroup = groupRef:getTarget()
		numNotes = noteGroup:getNumNotes()
		self.BREATH_DURATION = self:getMaxTimeGapFromBPM(groupRef:getOnset() + groupRef:getTimeOffset())
		self.MIN_GAP_FOR_BREATH = self:getMaxTimeGapFromBPM(groupRef:getOnset() + groupRef:getTimeOffset())
		
		-- Loop through all notes to find gaps
		for i = 1, numNotes - 1 do
			local currentNote = noteGroup:getNote(i)
			local nextNote = noteGroup:getNote(i + 1)

			local gapStart = currentNote:getOnset() + currentNote:getDuration()
			local gapEnd = nextNote:getOnset()
			local gapDuration = gapEnd - gapStart

			-- Check if gap is sufficient for a breath
			if gapDuration >= self.MIN_GAP_FOR_BREATH then
				local breathNote = self:createBreathNote(gapStart, nextNote, nextNote:getOnset()-currentNote:getEnd())
				noteGroup:addNote(breathNote)
				breathsInserted = breathsInserted + 1
			end
		end
	end

	if breathsInserted > 0 then
		self:show(string.format(SV:T("%d breath(s) added to track '%s'"), breathsInserted, track:getName()))
	end
end

-- Process selected notes
function NotesObject:processSelectedGroups(groupRef)
	local noteGroup = groupRef:getTarget()
	local breathsInserted = 0

	numNotes = noteGroup:getNumNotes()
	self.BREATH_DURATION = self:getMaxTimeGapFromBPM(groupRef:getOnset() + groupRef:getTimeOffset())
	self.MIN_GAP_FOR_BREATH = self:getMaxTimeGapFromBPM(groupRef:getOnset() + groupRef:getTimeOffset())
	
	-- Loop through all notes to find gaps
	for i = 1, numNotes - 1 do
		local currentNote = noteGroup:getNote(i)
		local nextNote = noteGroup:getNote(i + 1)

		local gapStart = currentNote:getOnset() + currentNote:getDuration()
		local gapEnd = nextNote:getOnset()
		local gapDuration = gapEnd - gapStart

		-- Check if gap is sufficient for a breath
		if gapDuration >= self.MIN_GAP_FOR_BREATH then
			local breathNote = self:createBreathNote(gapStart, nextNote, nextNote:getOnset()-currentNote:getEnd())
			noteGroup:addNote(breathNote)
			breathsInserted = breathsInserted + 1
		end
	end

	return breathsInserted
end

-- Create a breath note
function NotesObject:createBreathNote(onset, nextNote, duration)
	local breathNote = SV:create("Note")
	breathNote:setOnset(onset)
	breathNote:setDuration(duration)
	breathNote:setPitch(nextNote:getPitch())
	breathNote:setLyrics(self.BREATH_PHONEME)

	-- Parameters to make the breath more natural
	-- breathNote:setAttributes({
		-- tF0Offset = -100,  -- Slightly lower pitch
		-- tF0Left = -50,
		-- tF0Right = -50,
		-- dF0Left = 0.1,
		-- dF0Right = 0.1,
		-- tNoteOffset = 0
	-- })

	return breathNote
end

-- Start
function NotesObject:start()
	self.project:newUndoRecord()
	-- Get current selection or all tracks
	local groupsSelected = SV:getArrangement():getSelection():getSelectedGroups()
	local result = ""
	
	if not groupsSelected or #groupsSelected == 0 then
		result = "cancel"
		-- Ask for confirmation
		local bResult = SV:showOkCancelBox(SV:T(SCRIPT_TITLE),
				SV:T("Insert automatic breaths in current track (all groups)?")
				.. "\r" .. SV:T("No groups selected")
				.. "\r" .. SV:T("Cancel => to abort")
			)
		if bResult then
			result = "yes"
		end
	else
		-- Ask for confirmation
		result = SV:showYesNoCancelBox(SV:T(SCRIPT_TITLE),
				SV:T("Insert automatic breaths in current track (all groups)?")
				.. "\r" .. SV:T("No => limit to selected groups: ") .. #groupsSelected
				.. "\r" .. SV:T("Cancel => to abort")
			)
	end
	
	if result == "yes" then
			local track = self.currentTrack
			self:processTrack(track)
	else
		if result == "no" then			
			local breathsInserted = 0
			-- Process only selected group
			for _, refGroup in pairs(groupsSelected) do		
				breathsInserted = breathsInserted + self:processSelectedGroups(refGroup)
			end
			if breathsInserted > 0 then
				self:show(string.format(SV:T("%d breath(s) added to groups selected: ") .. #groupsSelected, breathsInserted))
			else
				self:show(SV:T("No sufficient gaps found between notes in selected groups:") .. #groupsSelected)
			end
		end
	end
	
	SV:finish()
end

-- Main processing task	
function main()
	local notesObject = NotesObject:new()
	notesObject:start()
end
