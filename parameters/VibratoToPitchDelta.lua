local SCRIPT_TITLE = 'Vibrato to pitch delta V1.1'

--[[

Synthesizer V Studio Pro Script
 
lua file name: VibratoToPitchDelta.lua

This script will recreate a vibrato envelope with pitch delta parameters
Save user updated dialog box parameters to external txt file (isPresetSave = true)

Set shortcut to ALT + V

2025 - JF AVILES
--]]

-- Generated by JFA TranslateScripts.lua
function getTranslations(langCode)
	return getArrayLanguageStrings()[langCode]
end

-- Generated by JFA TranslateScripts.lua
function getArrayLanguageStrings()
	return {
		["en-us"] = {
			{"Unable to save preset:", "Unable to save preset:"},
			{"Start/End note (%): ", "Start/End note (%): "},
			{"depth: ", "depth: "},
			{"Model: ", "Model: "},
			{"ERROR! Tempo not found!", "ERROR! Tempo not found!"},
			{"Preset: ", "Preset: "},
			{"Override vibrato depth", "Override vibrato depth"},
			{"Force rate and override frequency modulation", "Force rate and override frequency modulation"},
			{"Override start note", "Override start note"},
			{"%", "%"},
			{"Select a vibrato model", "Select a vibrato model"},
			{"Default model", "Default model"},
			{"Override a frequency model", "Override a frequency model"},
			{"Vibrato modulation", "Vibrato modulation"},
			{"Do not forget to reset Vibrato Modulation to 0", "Do not forget to reset Vibrato Modulation to 0"},
			{"in the Notes Panel!", "in the Notes Panel!"},
		},
	}
end

function getClientInfo()
	return {
		name = SV:T(SCRIPT_TITLE),
		category = "_JFA_Parameters",
		author = "JFAVILES",
		versionNumber = 2,
		minEditorVersion = 65540
	}
end

-- Define a class  "NotesObject"
NotesObject = {
	project = nil,
	timeAxis = nil,
	editor = nil,
	PARAMETER_REFERENCE = "pitchDelta",
	isPresetSave = true, 				-- preset data is saved into a local txt file project
	presetFileNameExtension = "-PresetVibrato.txt",
	presetRecord = "",
	presetValues = {},
	projectFileName = "",
	presetVibratoFileName = "",
	currentGroupRef = nil,
	currentGroupNotes = nil,
	paramsGroup = nil,
	currentTrack = nil,
	endTrackPosition = 0,
	selection = nil,
	selectedNotes = nil,
	hasSelectedNotes = false,
	newPoints = {},
	blicksPerSeconds = -1,
	currentBPM = 120,
	modulationDepth = 50,				-- Depth vibrato point to pitch parameter
	vibratoModels = {},
	vibratoModelsList = {},
	frequencyModulationActive = {},
	controlPointsMilliSeconds = 0.01, 	-- 0.01 = 10ms default
	defaultModel = true,				-- true to get default model
	defaultVibratoModel = 1,			-- 1 (1 to 3) default frequency vibrato model
	overrideStartDefaultValue = 0.240, 	-- 0.240 sec (0 to 1 sec) vibrato starting note
	overrideStartMinValue = 0,
	overrideStartMaxValue = 1,
	overrideStartLevelInterval = 0.01,
	overrideLeftDefaultValue = 0.20, 	-- 0.20 sec  (0.02 to 0.5 sec) vibrato Left
	overrideLeftMinValue = 0.20,
	overrideLeftMaxValue = 0.50,
	overrideLeftLevelInterval = 0.01,
	overrideRightDefaultValue = 0.20, 	-- 0.20 sec  (0.02 to 0.5 sec)vibrato Right
	overrideRightMinValue = 0.20,
	overrideRightMaxValue = 0.50,
	overrideRightLevelInterval = 0.01,
	overrideDepthDefaultValue = 1,		-- 1 semitone (0 to 2 smt) vibrato depth
	overrideDepthMinValue = 0,
	overrideDepthMaxValue = 2,
	overrideDepthLevelInterval = 0.01,
	overrideFreqDefaultValue = 5.5,		-- 5.5hz (1hz to 10hz) vibrato Freq
	overrideFreqMinValue = 1,
	overrideFreqMaxValue = 10,
	overrideFreqLevelInterval = 0.1,
	overridePhaseDefaultValue = 0,		-- 0x (-1.000 to 1.000x) vibrato Phase
	overridePhaseMinValue = -1,
	overridePhaseMaxValue = 1,
	overridePhaseLevelInterval = 0.01,
	modelSelected = 1,
	overrideStartSelected = 0.24,		-- 0.24 sec (0 to 1 sec)
	overrideLeftSelected = 0.2,			-- 0.2 sec  (0.02 to 0.5 sec)
	overrideRightSelected = 0.2,		-- 0.2 sec  (0.02 to 0.5 sec)
	overrideDepthSelected = 1,			-- 1 semitone (0 to 2 smt)
	overrideFreqSelected = 5.5,			-- 5.5hz (1hz to 10hz)
	overridePhaseSelected = 0,			-- 0x (-1.000 to 1.000x)
	timeGapSeconds = 0.01	-- Gap in milliseconds 1 millisecond = 1411200 blicks
}

-- Constructor method for the NotesObject class
function NotesObject:new()
    local notesObject = {}
    setmetatable(notesObject, self)
    self.__index = self
	
    self.project = SV:getProject()
    self.timeAxis = self.project:getTimeAxis()
    self.editor =  SV:getMainEditor()
	self.selection = self.editor:getSelection()
	self.newPoints = self.selection:getSelectedPoints(self.PARAMETER_REFERENCE)
	self.hasSelectedNotes = self.selection:hasSelectedNotes()
	self.selectedNotes = self.editor:getSelection():getSelectedNotes()
	self.currentGroupRef = self.editor:getCurrentGroup()
	self.currentGroupNotes = self.currentGroupRef:getTarget()
	if self.currentGroupNotes ~= nil then
		self.paramsGroup = self.currentGroupNotes:getParameter(self.PARAMETER_REFERENCE)
	end
	self.currentTrack = self.editor:getCurrentTrack()
	self.endTrackPosition = self.currentTrack:getGroupReference(self.currentTrack:getNumGroups()):getEnd()
	self.timeGapBlicks = self.timeAxis:getBlickFromSeconds(self.timeGapSeconds)
	
	self.vibratoModels = self:setVibratoModels() -- Add vibrato models
	self.vibratoModelsList = self:getVibratoModels()
	
	self.projectFileName = self.project:getFileName()
	self.presetVibratoFileName = self:getVibratoPresetFilePath(self.projectFileName)
	
    return self
end

-- Get vibrato preset file path
function NotesObject:getVibratoPresetFilePath(projectFileName)
	local notesFileName = projectFileName
	-- Update filename extension
	notesFileName = notesFileName:gsub("%.svp", self.presetFileNameExtension)
	return notesFileName
end

-- Save preset to text file
function NotesObject:savePresetToTextFile(preset, filename)
	local fo, errMessage = io.open(filename, "w")
	if fo then
	  fo:write(preset)
	  fo:close()
	else
	  self.show(SV:T("Unable to save preset:") .. "\r" .. errMessage)
	end
end

-- Read preset from text file
function NotesObject:readPresetFromTextFile(fileName)
	local notes = ""
	local fhandle = io.open(fileName, 'r')
	
	if fhandle ~= nil then
		-- Read file
		notes = fhandle:read("*a")
		io.close(fhandle)
	end
	return notes
end

-- Check if file exists
function NotesObject:isFileExists(fileName)
	local result = false
	local file = io.open(fileName, "r")
	if file ~= nil then
		io.close(file)
		result = true
	end
	return result
end

-- Get filename only
function NotesObject:getFileNameOnly(filename)
      return filename:match("^.+\\(.+)$")
end

-- Split string by sep char
function NotesObject:split(str, sep)
   local result = {}
   local regex = ("([^%s]+)"):format(sep)
   for each in str:gmatch(regex) do
	  table.insert(result, each)
   end
   return result
end

-- Set vibrato models
function NotesObject:setVibratoModels()
	-- {start=0.240, left=0.20, right=0.20, depth=1, freq=1, phase=0}
	-- {s=0.240, l=0.20, r=0.20, d=1, f=1, p=0}
	-- {s=start, l=left, r=right, d=depth, f=freq, p=phase}
	local vibratoModels = {
		{type="default", start=0.0, left=0.3, right=0.2, depth=1.25, freq=6.5, phase=0},
		{type="Progres", start=0.27, left=0.2, right=0.2, depth=1.14, freq=6.4, phase=0},
		{type="Smooth", start=0.2, left=0.2, right=0.2, depth=0.9, freq=5.5, phase=0}
	}	
	return vibratoModels
end

-- Set vibrato models
function NotesObject:getVibratoModels()
	local vibratoModelsList = {}

	for k, model in pairs(self.vibratoModels) do
		local modelList = model.type
			.. ": "
			.. model.start
			.. " (" .. SV:T("L") .. ":" .. model.left
			.. " " .. SV:T("R") .. ":" .. model.right
			.. ") " .. SV:T("Depth") .. ":" .. model.depth
			.. " " .. SV:T("Frq") .. ":" .. model.freq
			.. " " .. SV:T("Ph") .. ":" .. model.phase

		table.insert(vibratoModelsList, modelList)
	end
	return vibratoModelsList
end

-- Show message dialog
function NotesObject:show(message)
	SV:showMessageBox(SV:T(SCRIPT_TITLE), message)
end

-- Save into the clipboard
function NotesObject:saveToClipboard(message)
	SV:setHostClipboard(message)
end

-- Start check current group
function NotesObject:getObjectProperties(obj)
	local result = ""
	for k, v in pairs(obj) do
		if obj[k] ~= nil then
			result = result .. k .. "=" .. tostring(v) .. "\r"
		end
	end
	return result
end

-- Get current blicks per second
function NotesObject:getCurrentBlicksPerSecond(positionBlicks)
	local blicks = -1

	local bpm = self:getProjectTempo(positionBlicks)
	
	if bpm ~= nil then
		-- "120:" for 1s: blicks 1411200000 quarter 2
		-- "60: " for 1s: blicks 705600000 quarter 1
		blicks = SV:seconds2Blick(1, bpm) -- get blicks 1 second with bpm
		-- quarterBlicks = SV:blick2Quarter(blicks)
	end
	return blicks
end

-- Get current project tempo
function NotesObject:getProjectTempo(positionBlicks)
	local tempoActive = 120 -- default
	local tempoMarks = self.timeAxis:getAllTempoMarks()
	for iTempo = 1, #tempoMarks do
		local tempoMark = tempoMarks[iTempo]
		if tempoMark ~= nil and positionBlicks > tempoMark.position then
			tempoActive = tempoMark.bpm
		end
	end
	return math.floor(tempoActive)
end

-- Function to generate a vibrato effect
-- Parameters:
--   amplitude: oscillation amplitude (vibrato depth)
--   frequency: oscillation frequency in Hz
--   duration: total duration in seconds
--   sampleRate: number of samples per second
-- Returns: a table containing vibrato values over time
function NotesObject:generateVibrato(amplitude, frequency, duration, sampleRate)
    local samples = {}
    local totalSamples = math.floor(duration * sampleRate)
    
    -- For each sample
    for i = 1, totalSamples do
        local time = (i - 1) / sampleRate
        -- Sinusoidal oscillation formula for vibrato
        local value = amplitude * math.sin(2 * math.pi * frequency * time)
        samples[i] = {
            time = time,
            value = value
        }
    end
    
    return samples
end

-- Function that allows modifying the vibrato envelope with different parameters
-- Parameters:
--   amplitude: maximum oscillation amplitude
--   frequency: oscillation frequency in Hz
--   duration: total duration in seconds
--   sampleRate: number of samples per second
--   attackTime: attack time in seconds (gradual increase in amplitude)
--   releaseTime: release time in seconds (gradual decrease in amplitude)
--   frequencyModulation: optional table to modulate frequency over time
function NotesObject:generateAdvancedVibrato(amplitude, frequency, duration, sampleRate, attackTime, releaseTime, frequencyModulation)
    local samples = {}
    local totalSamples = math.floor(duration * sampleRate)
    
    -- For each sample
    for i = 1, totalSamples do
        local time = (i - 1) / sampleRate
        local currentAmplitude = amplitude
        
        -- Apply attack envelope
        if time < attackTime then
            currentAmplitude = amplitude * (time / attackTime)
        end
        
        -- Apply release envelope
        if time > (duration - releaseTime) then
            local releasePhase = (time - (duration - releaseTime)) / releaseTime
            currentAmplitude = amplitude * (1 - releasePhase)
        end
        
        -- Apply frequency modulation if provided
        local currentFrequency = frequency
        if frequencyModulation then
            local modulationIndex = math.floor(time / duration * #frequencyModulation) + 1
            if modulationIndex <= #frequencyModulation then
                currentFrequency = frequencyModulation[modulationIndex]
            end
        end
        
        -- Calculate vibrato value
        local value = currentAmplitude * math.sin(2 * math.pi * currentFrequency * time)
        
        samples[i] = {
            time = time,
            value = value
        }
    end
    
    return samples
end

-- Function to apply vibrato to a MIDI note
-- Parameters:
--   noteStartTime: note start time in ticks
--   noteDuration: note duration in ticks
--   ticksPerSecond: ticks to seconds conversion
--   vibratoDelay: delay before vibrato starts in seconds
--   vibratoParams: vibrato parameters (amplitude, frequency, etc.)
function NotesObject:applyVibratoToNote(noteStartTime, noteDuration, ticksPerSecond, vibratoDelay, vibratoParams)
    -- Convert ticks to seconds
    local startTimeSeconds = noteStartTime / ticksPerSecond
    local durationSeconds = noteDuration / ticksPerSecond
	
    -- Adjust vibrato duration accounting for delay
    local vibratoDuration = durationSeconds - vibratoDelay
    if vibratoDuration <= 0 then
        return {} -- Note is too short to apply vibrato
    end
    
    -- Generate vibrato
    local vibratoPoints = self:generateAdvancedVibrato(
        vibratoParams.amplitude,
        vibratoParams.frequency,
        vibratoDuration,
        vibratoParams.sampleRate,
        vibratoParams.attackTime,
        vibratoParams.releaseTime,
        vibratoParams.frequencyModulation
    )
    
    -- Add delay to the time of each point
    local finalVibratoPoints = {}
    for i, point in ipairs(vibratoPoints) do
        table.insert(finalVibratoPoints, {
            time = startTimeSeconds + vibratoDelay + point.time,
            value = point.value
        })
    end
    
    return finalVibratoPoints
end

-- Export vibrato to control points for SynthesizerV or similar software
function NotesObject:exportVibratoToControlPoints(vibratoPoints, controlPointInterval)
    local controlPoints = {}
    
    -- Convert to control points at regular intervals
    local interval = controlPointInterval or 0.01 -- 10ms default
    local currentIndex = 1
    
    while currentIndex <= #vibratoPoints do
        local point = vibratoPoints[currentIndex]
        
        table.insert(controlPoints, {
            time = point.time,
            value = point.value
        })
        
        -- Find the next point at the specified interval
        local nextTime = point.time + interval
        while currentIndex < #vibratoPoints and vibratoPoints[currentIndex + 1].time < nextTime do
            currentIndex = currentIndex + 1
        end
        
        currentIndex = currentIndex + 1
    end
    
    return controlPoints
end

-- Get vibrato points
function NotesObject:getVibratoPoints(ticksPerSecond, noteStartTick, noteDurationTicks, 
										vibratoDelay, vibratoParams)
    -- Generate vibrato points
    local vibratoPoints = self:applyVibratoToNote(
        noteStartTick, 
        noteDurationTicks, 
        ticksPerSecond, 
        vibratoDelay, 
        vibratoParams
    )
    
    -- Convert to control points -- 0.01 = 10ms default
    local controlPoints = self:exportVibratoToControlPoints(vibratoPoints, self.controlPointsMilliSeconds)
    
    -- -- Control points
    -- result = result .. "Vibrato control points:"
    -- for i, point in ipairs(controlPoints) do
        -- result = result .. string.format("Time: %.2fs, Value: %.4f", point.time, point.value)
		-- .. "\r"
    -- end
    
    return controlPoints
end

-- Add vibrato to selected notes
function NotesObject:addVibratoToSelectedNotes(vibratoParams, notePosStart, vibratoStartNote)
	
	-- Loop all selected notes
	for k, note in pairs(self.selectedNotes) do
		local notePos = note:getOnset()
		local notePosEnd = note:getEnd()
		local noteDuration = note:getDuration()
		local paramPitchDelta = self.currentGroupNotes:getParameter(self.PARAMETER_REFERENCE)
		local noteDurationSeconds = self.timeAxis:getSecondsFromBlick(noteDuration)
		local vibratoDelayInSeconds = noteDurationSeconds * vibratoStartNote

		self.currentBPM = self:getProjectTempo(notePos)
		self.blicksPerSeconds = self:getCurrentBlicksPerSecond(notePos)
		
		if self.blicksPerSeconds == -1 then
			self:show(SV:T("ERROR! Tempo not found!"))
			break
		else
			-- Clear all previous pitchDelta parameters
			paramPitchDelta:remove(notePos, notePosEnd)
			
			-- Get vibrato points
			local points = self:getVibratoPoints(self.blicksPerSeconds, 
											notePosStart, noteDuration, 
											vibratoDelayInSeconds,
											vibratoParams)
			-- self:saveToClipboard(pointsString)
			self:addPointsToPitchDeltaParameter(notePos, points, paramPitchDelta)
		end
	end
end

-- Add points to pitch delta parameter
function NotesObject:addPointsToPitchDeltaParameter(notePos, points, paramPitchDelta)
	-- Apply vibrato to pitchDelta parameters
	local newPos = notePos
	local isSimplify = false -- not used default
	
	for k, point in pairs(points) do
		newPos = notePos + self.timeAxis:getBlickFromSeconds(point.time)
		paramPitchDelta:add(newPos, point.value * self.modulationDepth)
	end

	-- Add a last point to stop pitch modulation
	newPos = newPos + self.timeGapBlicks
	paramPitchDelta:add(newPos, 0)
	
	
	if isSimplify then 
		local threshold = 0.01 -- 0.002 default
		paramPitchDelta:simplify(notePos, newPos, threshold)
	end
end

-- Create user input form
function NotesObject:getForm()
	
	local newVibratoModel = self.defaultVibratoModel
	local newOverrideStartValue = self.overrideStartDefaultValue
	local newOverrideLeftValue = self.overrideLeftDefaultValue
	local newOverrideRightValue = self.overrideRightDefaultValue
	local newOverrideDepthValue = self.overrideDepthDefaultValue
	local newOverrideFreqValue = self.overrideFreqDefaultValue
	local newOverridePhaseValue = self.overridePhaseDefaultValue
	local presetLabel = ""
	local defaultModelLabel = SV:T("Default values")
	
	if #self.presetValues > 0 then
		newVibratoModel = self.presetValues[1].vibratoModel
		newOverrideStartValue = self.presetValues[1].overrideStart
		newOverrideLeftValue = self.presetValues[1].overrideLeft
		newOverrideRightValue = self.presetValues[1].overrideRight
		newOverrideDepthValue =  self.presetValues[1].overrideDepth
		newOverrideFreqValue =  self.presetValues[1].overrideFreq
		newOverridePhaseValue =  self.presetValues[1].overridePhase
		presetLabel = SV:T("Preset: ") .. self:getFileNameOnly(self.presetVibratoFileName)
	end
	self.modelSelected = newVibratoModel

	local newValues = {model = self.modelSelected,
		overrideStart = newOverrideStartValue,
		overrideLeft = newOverrideLeftValue,
		overrideRight = newOverrideRightValue,
		overrideDepth = newOverrideDepthValue,
		overrideFreq = newOverrideFreqValue,
		overridePhase = newOverridePhaseValue
	}	
	self.defaultModel = self:isDefaultValues(newValues)
	
	if not self.defaultModel then
		defaultModelLabel = SV:T("Values overrided!")
	end

	local defaultModelInfo = {
				name = "separator", type = "TextArea", label = defaultModelLabel, height = 0
			}
	
	local sliderOverrideStart = {
			name = "overrideStart", type = "Slider",
			label = SV:T("Override start note"),
			format = "%1.3f" .. " " .. SV:T("sec") .. " " .. SV:T("start"),
			minValue = self.overrideStartMinValue, 
			maxValue = self.overrideStartMaxValue, 
			interval = self.overrideStartLevelInterval, 
			default  = newOverrideStartValue
		}
	local sliderOverrideLeft  = {
			name = "overrideLeft", type = "Slider",
			label = SV:T("Override left"),
			format = "%1.2f" .. " " .. SV:T("sec") .. " " .. SV:T("left"),
			minValue = self.overrideLeftMinValue, 
			maxValue = self.overrideLeftMaxValue, 
			interval = self.overrideLeftLevelInterval, 
			default  = newOverrideLeftValue
		}
	local sliderOverrideRight  = {
			name = "overrideRight", type = "Slider",
			label = SV:T("Override right"),
			format = "%1.2f" .. " " .. SV:T("sec") .. " " .. SV:T("right"),
			minValue = self.overrideRightMinValue, 
			maxValue = self.overrideRightMaxValue, 
			interval = self.overrideRightLevelInterval, 
			default  = newOverrideRightValue
		}
	
	local sliderOverrideDepth = {
			name = "overrideDepth", type = "Slider",
			label = SV:T("Override vibrato depth"),
			format = "%1.2f" .. " " .. SV:T("smt") .. " " .. SV:T("depth"),
			minValue = self.overrideDepthMinValue, 
			maxValue = self.overrideDepthMaxValue, 
			interval = self.overrideDepthLevelInterval, 
			default  = newOverrideDepthValue
		}

	local sliderOverrideFreq = {
			name = "overrideFreq", type = "Slider",
			label = SV:T("Frequency"),
			format = "%1.2f" .. " " .. SV:T("Hz") .. " " .. SV:T("freq"),
			minValue = self.overrideFreqMinValue, 
			maxValue = self.overrideFreqMaxValue, 
			interval = self.overrideFreqLevelInterval, 
			default  = newOverrideFreqValue
		}
	local sliderOverridePhase = {
			name = "overridePhase", type = "Slider",
			label = SV:T("Phase"),
			format = "%1.3f" .. " " .. SV:T("x") .. " " .. SV:T("phase"),
			minValue = self.overridePhaseMinValue, 
			maxValue = self.overridePhaseMaxValue, 
			interval = self.overridePhaseLevelInterval, 
			default  = newOverridePhaseValue
		}

	if #self.vibratoModelsList > 0 then
		vibratoComboChoice = {
			name = "vibratoModel", type = "ComboBox", label = SV:T("Select a vibrato model"), 
			choices = self.vibratoModelsList, default = newVibratoModel - 1
		}
	end

	local checkboxResetDefaultValues = {
			name = "isResetDefaultValues",
			text = SV:T("Reset to default values"),
			type = "CheckBox",
			default = false
		}


	local form = {
		title = SV:T(SCRIPT_TITLE),
		message = SV:T("Vibrato modulation") .. "\r",
		buttons = "OkCancel",
		widgets = {
			{
				name = "modulationReset", type = "TextArea", 
				label = SV:T("Do not forget to reset Vibrato Modulation to 0") .. "\r"
					.. SV:T("in the Notes Panel!"), 
				height = 0
			},
			vibratoComboChoice,
			defaultModelInfo,
			sliderOverrideStart,
			sliderOverrideLeft,
			sliderOverrideRight,
			sliderOverrideDepth,
			sliderOverrideFreq,
			sliderOverridePhase,
			checkboxResetDefaultValues,
			{
				name = "separator", type = "TextArea", label = presetLabel, height = 0
			},
		}
	}
	return SV:showCustomDialog(form)
end

-- Get preset content
function NotesObject:getPresetContent(presetContent)
	local presetValues = {}
	local preset = "" -- preset:
	local vibratoModel = self.modelSelected
	local overrideStart = self.overrideStartSelected
	local overrideLeft = self.overrideLeftSelected
	local overrideRight = self.overrideRightSelected
	local overrideDepth =  self.overrideDepthSelected
	local overrideFreq = self.overrideFreqSelected
	local overridePhase = self.overridePhaseSelected
	
	if #presetContent > 0 then
		preset = self:split(presetContent, ":")[2] -- preset:
		if #preset > 0 then
			local tagPreset = self:split(preset, ",")
			for _, tagItem in pairs(tagPreset) do
				local tagContent = self:split(tagItem, "=")
				local tagName = tagContent[1]
				local tagValue = tagContent[2]
				
				if tagName == "vibratoModel" then
					vibratoModel = tonumber(tagValue)
				end
				if tagName == "overrideStart" then
					overrideStart = tonumber(tagValue)
				end
				if tagName == "overrideLeft" then
					overrideLeft = tonumber(tagValue)
				end
				if tagName == "overrideRight" then
					overrideRight = tonumber(tagValue)
				end
				if tagName == "overrideDepth" then
					overrideDepth =  tonumber(tagValue)
				end
				if tagName == "overrideFreq" then
					overrideFreq = tonumber(tagValue)
				end
				if tagName == "overridePhase" then
					overridePhase = tonumber(tagValue)
				end
			end
			
			table.insert(presetValues, {
				vibratoModel = vibratoModel,
				overrideStart = overrideStart,
				overrideLeft = overrideLeft,
				overrideRight = overrideRight,
				overrideDepth = overrideDepth,
				overrideFreq = overrideFreq,
				overridePhase = overridePhase
				})
		end
	end
	return presetValues
end

-- Set data preset
function NotesObject:setDataPreset()
	local presetContent = "Preset1:"
	presetContent = presetContent .. "vibratoModel=" .. self.modelSelected .. ","
	presetContent = presetContent .. "overrideStart=" .. self.overrideStartSelected .. ","
	presetContent = presetContent .. "overrideLeft=" .. self.overrideLeftSelected .. ","
	presetContent = presetContent .. "overrideRight=" .. self.overrideRightSelected .. ","
	presetContent = presetContent .. "overrideDepth=" .. self.overrideDepthSelected .. ","
	presetContent = presetContent .. "overrideFreq=" .. self.overrideFreqSelected .. ","
	presetContent = presetContent .. "overridePhase=" .. self.overridePhaseSelected
	
	return presetContent
end

-- Is values overrided
function NotesObject:isDefaultValues(newValues)
	local isDefaultValues = true
	-- local vibratoModel = self.vibratoModels[self.modelSelected].vibratoModel
	local startModel = self.vibratoModels[self.modelSelected].start
	local leftModel = self.vibratoModels[self.modelSelected].left
	local rightModel = self.vibratoModels[self.modelSelected].right
	local depthModel = self.vibratoModels[self.modelSelected].depth
	local freqModel = self.vibratoModels[self.modelSelected].freq
	local phaseModel = self.vibratoModels[self.modelSelected].phase

	-- Check if overrided values
	if startModel ~= newValues.overrideStart or
		leftModel ~= newValues.overrideLeft or
		rightModel ~= newValues.overrideRight or
		depthModel ~= newValues.overrideDepth or
		freqModel ~= newValues.overrideFreq or
		phaseModel ~= newValues.overridePhase then
		
		isDefaultValues = false
	end
	return isDefaultValues
end

-- Get new value if different
function NotesObject:getNewValue(defaultValue, newValue)
	local newVal = defaultValue
	if modelValue ~= newValue then
		newVal = newValue
	end
	return newVal
end

-- Start process
function NotesObject:start()
	if self.isPresetSave then
		self.presetRecord = self:readPresetFromTextFile(self.presetVibratoFileName)
		self.presetValues = self:getPresetContent(self.presetRecord)		
	end

	local userInput = self:getForm()
	
	if userInput.status then
		if userInput.answers.vibratoModel ~= nil then
			local valuesFromModel = false
			local newModelSelected = userInput.answers.vibratoModel + 1 -- see self.vibratoModel
			-- Get override values by user
			local overrideStartSelected = userInput.answers.overrideStart
			local overrideLeftSelected = userInput.answers.overrideLeft
			local overrideRightSelected = userInput.answers.overrideRight
			local overrideDepthSelected = userInput.answers.overrideDepth
			local overrideFreqSelected = userInput.answers.overrideFreq
			local overridePhaseSelected = userInput.answers.overridePhase			
			local isResetDefaultValues = userInput.answers.isResetDefaultValues
			
			-- {type="default", start=0.240, left=0.20, right=0.20, depth=1, freq=1, phase=0},
			-- Get model values
			local startModel = self.vibratoModels[newModelSelected].start
			local leftModel = self.vibratoModels[newModelSelected].left
			local rightModel = self.vibratoModels[newModelSelected].right
			local depthModel = self.vibratoModels[newModelSelected].depth
			local freqModel = self.vibratoModels[newModelSelected].freq
			local phaseModel = self.vibratoModels[newModelSelected].phase
			
			if newModelSelected ~= self.modelSelected then
				valuesFromModel = true
			end
			self.modelSelected = newModelSelected
			
			-- Get values from model
			self.overrideStartSelected = startModel
			self.overrideLeftSelected = leftModel
			self.overrideRightSelected = rightModel
			self.overrideDepthSelected = depthModel
			self.overrideFreqSelected = freqModel
			self.overridePhaseSelected = phaseModel
			
			-- If checkbox checked use default model values or model is new
			if not isResetDefaultValues and not valuesFromModel then
				-- Check if overrided values
				self.overrideStartSelected = self:getNewValue(startModel, overrideStartSelected)
				self.overrideLeftSelected = self:getNewValue(leftModel, overrideLeftSelected)
				self.overrideRightSelected = self:getNewValue(rightModel, overrideRightSelected)
				self.overrideDepthSelected = self:getNewValue(depthModel, overrideDepthSelected)
				self.overrideFreqSelected = self:getNewValue(freqModel, overrideFreqSelected)
				self.overridePhaseSelected = self:getNewValue(phaseModel, overridePhaseSelected)
			end

			-- Get phase to decay phase
			self.frequencyModulationActive = {self.overrideFreqSelected}
			local notePosStart = self.overridePhaseSelected * (SV.QUARTER/8) * - 1
			
			-- Vibrato parameters
			local vibratoParams = {
				amplitude = self.overrideDepthSelected,		-- Half-tone (+/- 50 cents)
				frequency = self.overrideFreqSelected,		-- 5.5 Hz (cycles per second)
				sampleRate = 100,							-- 100 samples per second
				attackTime = self.overrideLeftSelected,		-- 100ms attack for 0.1 and 0.5
				releaseTime = self.overrideRightSelected,	-- 300ms release for 0.3
				frequencyModulation = self.frequencyModulationActive
			}
		

			self:addVibratoToSelectedNotes(vibratoParams, notePosStart, self.overrideStartSelected)
			
			if self.isPresetSave then
				self.presetContent = self:setDataPreset()
				self:savePresetToTextFile(self.presetContent, self.presetVibratoFileName)
			end
		end
		self:start()
	end
end

-- Main process
function main()
	local notesObject = NotesObject:new()
	if notesObject.hasSelectedNotes then
		notesObject:start()
	else
		notesObject:show(SV:T("No note selected!"))
	end	
	SV:finish()
end