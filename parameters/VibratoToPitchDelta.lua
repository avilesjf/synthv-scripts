local SCRIPT_TITLE = 'Vibrato to pitch delta V1.0'

--[[

Synthesizer V Studio Pro Script
 
lua file name: VibratoToPitchDelta.lua

This script will recreate a vibrato envelope with pitch delta parameters
Save user updated dialog box values to external txt file (isPresetSave = true)

Set shortcut to ALT + V

2025 - JF AVILES
--]]

-- Generated by JFA TranslateScripts.lua
function getTranslations(langCode)
	return getArrayLanguageStrings()[langCode]
end

-- Generated by JFA TranslateScripts.lua
function getArrayLanguageStrings()
	return {
		["en-us"] = {
			{"Unable to save preset:", "Unable to save preset:"},
			{"Start/End note (%): ", "Start/End note (%): "},
			{"Depth: ", "Depth: "},
			{"Model: ", "Model: "},
			{"ERROR! Tempo not found!", "ERROR! Tempo not found!"},
			{"Preset: ", "Preset: "},
			{"Override vibrato depth", "Override vibrato depth"},
			{"Depth", "Depth"},
			{"Force rate and override frequency modulation", "Force rate and override frequency modulation"},
			{"Rate", "Rate"},
			{"Override start note", "Override start note"},
			{"%", "%"},
			{"Progressive vibrato", "Progressive vibrato"},
			{"Select a vibrato model", "Select a vibrato model"},
			{"Default model", "Default model"},
			{"Override a frequency model", "Override a frequency model"},
			{"Vibrato modulation", "Vibrato modulation"},
			{"Do not forget to reset Vibrato Modulation to 0", "Do not forget to reset Vibrato Modulation to 0"},
			{"in the Notes Panel!", "in the Notes Panel!"},
		},
	}
end

function getClientInfo()
	return {
		name = SV:T(SCRIPT_TITLE),
		category = "_JFA_Parameters",
		author = "JFAVILES",
		versionNumber = 1,
		minEditorVersion = 65540
	}
end

-- Define a class  "NotesObject"
NotesObject = {
	project = nil,
	timeAxis = nil,
	editor = nil,
	PARAMETER_REFERENCE = "pitchDelta",
	isPresetSave = true, 				-- preset data is saved into a local txt file project
	presetFileNameExtension = "-PresetVibrato.txt",
	presetRecord = "",
	presetValues = {},
	projectFileName = "",
	presetVibratoFileName = "",
	currentGroupRef = nil,
	currentGroupNotes = nil,
	paramsGroup = nil,
	currentTrack = nil,
	endTrackPosition = 0,
	selection = nil,
	selectedNotes = nil,
	newPoints = {},
	blicksPerSeconds = -1,
	quarterBlicks = -1,
	currentBPM = 120,
	coefModulation = 100,
	vibratoModels = {},
	vibratoModelsList = {},
	frequencyModModels = {},
	frequencyModModelsList = {},
	frequencyModulationDefault = 6.0,
	controlPointsMilliSeconds = 0.02, 	-- 0.01 = 10ms default
	attackTimeDefault = 0.1,			-- default attack
	attackTimeProgressive = 0.5,		-- attenuate attack for progressive vibrato
	progressiveVibrato = false,			-- default progressive vibrato
	defaultVibratoModel = 1,			-- 1 (1 to 3) default frequency vibrato model
	defaultFrequencyModel = 1,			-- 1 default frequency model
	overrideDepthDefaultValue = 1,		-- 1 (0.5 to 1.5) default vibrato depth
	overrideDepthMinValue = 0.5,
	overrideDepthMaxValue = 2,
	overrideDepthLevelInterval = 0.25,
	overrideRateDefaultValue = 1,		-- 1 (0.1 to 2) default vibrato rate
	overrideRateMinValue = 0.5,
	overrideRateMaxValue = 1.5,
	overrideRateLevelInterval = 0.1,
	overrideStartDefaultValue = 0, 		-- 0 (0 to 50%) default vibrato starting note
	overrideStartMinValue = 0,
	overrideStartMaxValue = 50,
	overrideStartLevelInterval = 5,
	modelSelected = 1,
	overrideDepthSelected = 1, 
	overrideRateSelected = 1,
	overrideFrequencyModelSelected = 0,
	overrideStartSelected = 0,
	timeGapSeconds = 0.01	-- Gap in milliseconds 1 millisecond = 1411200 blicks
}

-- Constructor method for the NotesObject class
function NotesObject:new()
    local notesObject = {}
    setmetatable(notesObject, self)
    self.__index = self
	
    self.project = SV:getProject()
    self.timeAxis = self.project:getTimeAxis()
    self.editor =  SV:getMainEditor()
	self.selection = self.editor:getSelection()
	self.newPoints = self.selection:getSelectedPoints(self.PARAMETER_REFERENCE)
	self.selectedContent = self.selection:hasSelectedContent()
	self.selectedNotes = self.editor:getSelection():getSelectedNotes()
	self.currentGroupRef = self.editor:getCurrentGroup()
	self.currentGroupNotes = self.currentGroupRef:getTarget()
	if self.currentGroupNotes ~= nil then
		self.paramsGroup = self.currentGroupNotes:getParameter(self.PARAMETER_REFERENCE)
	end
	self.currentTrack = self.editor:getCurrentTrack()
	self.endTrackPosition = self.currentTrack:getGroupReference(self.currentTrack:getNumGroups()):getEnd()
	self.timeGapBlicks = self.timeAxis:getBlickFromSeconds(self.timeGapSeconds)
	
	self.vibratoModels = self:setVibratoModels() -- Add vibrato models
	self.frequencyModModels = self:setFrequencyModulationModels() -- Add frequency models
	self.frequencyModModelActive = self.frequencyModModels[1]
	self.vibratoModelsList = self:getVibratoModels()
	self.frequencyModModelsList = self:getFrequencyModulationModelsList()
	
	self.projectFileName = self.project:getFileName()
	self.presetVibratoFileName = self:getVibratoPresetFilePath(self.projectFileName)
	
    return self
end

-- Get vibrato preset file path
function NotesObject:getVibratoPresetFilePath(projectFileName)
	local notesFileName = projectFileName
	-- Update filename extension
	notesFileName = notesFileName:gsub("%.svp", self.presetFileNameExtension)
	return notesFileName
end

-- Save preset to text file
function NotesObject:savePresetToTextFile(preset, filename)
	local fo, errMessage = io.open(filename, "w")
	if fo then
	  fo:write(preset)
	  fo:close()
	else
	  self.show(SV:T("Unable to save preset:") .. "\r" .. errMessage)
	end
end

-- Read preset from text file
function NotesObject:readPresetFromTextFile(fileName)
	local notes = ""
	local fhandle = io.open(fileName, 'r')
	
	if fhandle ~= nil then
		-- Read file
		notes = fhandle:read("*a")
		io.close(fhandle)
	end
	return notes
end

-- Check if file exists
function NotesObject:isFileExists(fileName)
	local result = false
	local file = io.open(fileName, "r")
	if file ~= nil then
		io.close(file)
		result = true
	end
	return result
end

-- Get filename only
function NotesObject:getFileNameOnly(filename)
      return filename:match("^.+\\(.+)$")
end

-- Split string by sep char
function NotesObject:split(str, sep)
   local result = {}
   local regex = ("([^%s]+)"):format(sep)
   for each in str:gmatch(regex) do
	  table.insert(result, each)
   end
   return result
end

-- Set vibrato models
function NotesObject:setVibratoModels()
	-- startNote, endNote in percentage
	-- vibratoDepth a coefficient of vibrato depth
	-- frequencyModModel variation in time
	local vibratoModels = {
		{startNote = 0,	 vibratoDepth = 1.5, endNote = 0, frequencyModModel = 1},
		{startNote = 30, vibratoDepth = 1.2, endNote = 0, frequencyModModel = 1},
		{startNote = 50, vibratoDepth = 1.5, endNote = 0, frequencyModModel = 3}
	}	
	return vibratoModels
end

-- Set frequency modulation models
function NotesObject:setFrequencyModulationModels()
	local frequencyModulations = {
		{5.7, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0},
		{5.5, 5.7, 6.0, 6.2, 6.2, 6.2, 5.0},
		{6.2}
	}
	return frequencyModulations
end

-- Get frequency modulation model
function NotesObject:getFrequencyModulationModel(model)
	local result = ""
	local sep = ""
	for i, val in pairs(self.frequencyModModels[model]) do
		result = result .. sep .. val
		sep = ", "
	end
	return result
end

-- Get frequency modulation models list
function NotesObject:getFrequencyModulationModelsList()
	local frequencyModulationModelsList = {}
	for i, freq in pairs(self.frequencyModModels) do
		local modelList = ""
		local sep = ""
		for j, val in pairs(freq) do
			modelList = modelList .. sep .. val
			sep = ", "
		end
		table.insert(frequencyModulationModelsList, modelList)
	end
	return frequencyModulationModelsList
end

-- Set vibrato models
function NotesObject:getVibratoModels()
	local vibratoModelsList = {}

	for k, model in pairs(self.vibratoModels) do
		local modelList = SV:T("Start/End note (%): ") 
			.. model.startNote .. "/" .. model.endNote
			.. ", " .. SV:T("Depth: ") .. model.vibratoDepth
			.. ", " .. SV:T("Model: ") .. model.frequencyModModel
		table.insert(vibratoModelsList, modelList)
	end
	return vibratoModelsList
end

-- Show message dialog
function NotesObject:show(message)
	SV:showMessageBox(SV:T(SCRIPT_TITLE), message)
end

-- Save into the clipboard
function NotesObject:saveToClipboard(message)
	SV:setHostClipboard(message)
end

-- Start check current group
function NotesObject:getObjectProperties(obj)
	local result = ""
	for k, v in pairs(obj) do
		if obj[k] ~= nil then
			result = result .. k .. "=" .. tostring(v) .. "\r"
		end
	end
	return result
end

-- Get current blicks per second & quarter 
function NotesObject:getCurrentBlicksPerSecond(positionBlicks)
	local blicks = -1
	local quarterBlicks = -1

	local bpm = self:getProjectTempo(positionBlicks)
	
	if bpm ~= nil then
		-- "120:" for 1s: blicks 1411200000 quarter 2
		-- "60: " for 1s: blicks 705600000 quarter 1
		blicks = SV:seconds2Blick(1, bpm) -- get blicks 1 second with bpm
		quarterBlicks = SV:blick2Quarter(blicks)
	end
	return blicks, quarterBlicks
end

-- Get current project tempo
function NotesObject:getProjectTempo(positionBlicks)
	local tempoActive = 120 -- default
	local tempoMarks = self.timeAxis:getAllTempoMarks()
	for iTempo = 1, #tempoMarks do
		local tempoMark = tempoMarks[iTempo]
		if tempoMark ~= nil and positionBlicks > tempoMark.position then
			tempoActive = tempoMark.bpm
		end
	end
	return math.floor(tempoActive)
end

-- Function to generate a vibrato effect
-- Parameters:
--   amplitude: oscillation amplitude (vibrato depth)
--   frequency: oscillation frequency in Hz
--   duration: total duration in seconds
--   sampleRate: number of samples per second
-- Returns: a table containing vibrato values over time
function NotesObject:generateVibrato(amplitude, frequency, duration, sampleRate)
    local samples = {}
    local totalSamples = math.floor(duration * sampleRate)
    
    -- For each sample
    for i = 1, totalSamples do
        local time = (i - 1) / sampleRate
        -- Sinusoidal oscillation formula for vibrato
        local value = amplitude * math.sin(2 * math.pi * frequency * time)
        samples[i] = {
            time = time,
            value = value
        }
    end
    
    return samples
end

-- Function that allows modifying the vibrato envelope with different parameters
-- Parameters:
--   amplitude: maximum oscillation amplitude
--   frequency: oscillation frequency in Hz
--   duration: total duration in seconds
--   sampleRate: number of samples per second
--   attackTime: attack time in seconds (gradual increase in amplitude)
--   releaseTime: release time in seconds (gradual decrease in amplitude)
--   frequencyModulation: optional table to modulate frequency over time
function NotesObject:generateAdvancedVibrato(amplitude, frequency, duration, sampleRate, attackTime, releaseTime, frequencyModulation)
    local samples = {}
    local totalSamples = math.floor(duration * sampleRate)
    
    -- For each sample
    for i = 1, totalSamples do
        local time = (i - 1) / sampleRate
        local currentAmplitude = amplitude
        
        -- Apply attack envelope
        if time < attackTime then
            currentAmplitude = amplitude * (time / attackTime)
        end
        
        -- Apply release envelope
        if time > (duration - releaseTime) then
            local releasePhase = (time - (duration - releaseTime)) / releaseTime
            currentAmplitude = amplitude * (1 - releasePhase)
        end
        
        -- Apply frequency modulation if provided
        local currentFrequency = frequency
        if frequencyModulation then
            local modulationIndex = math.floor(time / duration * #frequencyModulation) + 1
            if modulationIndex <= #frequencyModulation then
                currentFrequency = frequencyModulation[modulationIndex]
            end
        end
        
        -- Calculate vibrato value
        local value = currentAmplitude * math.sin(2 * math.pi * currentFrequency * time)
        
        samples[i] = {
            time = time,
            value = value
        }
    end
    
    return samples
end

-- Function to apply vibrato to a MIDI note
-- Parameters:
--   noteStartTime: note start time in ticks
--   noteDuration: note duration in ticks
--   ticksPerSecond: ticks to seconds conversion
--   vibratoDelay: delay before vibrato starts in seconds
--   vibratoParams: vibrato parameters (amplitude, frequency, etc.)
function NotesObject:applyVibratoToNote(noteStartTime, noteDuration, ticksPerSecond, vibratoDelay, vibratoParams)
    -- Convert ticks to seconds
    local startTimeSeconds = noteStartTime / ticksPerSecond
    local durationSeconds = noteDuration / ticksPerSecond
	-- self:show("startTimeSeconds: "  .. startTimeSeconds
		-- .. ", noteStartTime: " .. noteStartTime
		-- .. ", ticksPerSecond: " .. ticksPerSecond
		-- .. ", durationSeconds: " .. durationSeconds
		-- .. ", noteDuration: " .. noteDuration
		-- )
	-- if 1 == 0 then
		-- return {}
	-- end
    -- Adjust vibrato duration accounting for delay
    local vibratoDuration = durationSeconds - vibratoDelay
    if vibratoDuration <= 0 then
        return {} -- Note is too short to apply vibrato
    end
    
    -- Generate vibrato
    local vibratoPoints = self:generateAdvancedVibrato(
        vibratoParams.amplitude,
        vibratoParams.frequency,
        vibratoDuration,
        vibratoParams.sampleRate,
        vibratoParams.attackTime,
        vibratoParams.releaseTime,
        vibratoParams.frequencyModulation
    )
    
    -- Add delay to the time of each point
    local finalVibratoPoints = {}
    for i, point in ipairs(vibratoPoints) do
        table.insert(finalVibratoPoints, {
            time = startTimeSeconds + vibratoDelay + point.time,
            value = point.value
        })
    end
    
    return finalVibratoPoints
end

-- Export vibrato to control points for SynthesizerV or similar software
function NotesObject:exportVibratoToControlPoints(vibratoPoints, controlPointInterval)
    local controlPoints = {}
    
    -- Convert to control points at regular intervals
    local interval = controlPointInterval or 0.01 -- 10ms default
    local currentIndex = 1
    
    while currentIndex <= #vibratoPoints do
        local point = vibratoPoints[currentIndex]
        
        table.insert(controlPoints, {
            time = point.time,
            value = point.value
        })
        
        -- Find the next point at the specified interval
        local nextTime = point.time + interval
        while currentIndex < #vibratoPoints and vibratoPoints[currentIndex + 1].time < nextTime do
            currentIndex = currentIndex + 1
        end
        
        currentIndex = currentIndex + 1
    end
    
    return controlPoints
end

-- Get vibrato points
function NotesObject:getVibratoPoints(ticksPerSecond, noteStartTick, noteDurationTicks, 
										vibratoDelay, frequencyModulationActive,
										isProgressiveVibrato)
    local attackTimeActive = self.attackTimeDefault
	if isProgressiveVibrato then
		attackTimeActive = self.attackTimeProgressive
	end
	
	-- Vibrato parameters
    local vibratoParams = {
        amplitude = 0.5,       -- Half-tone (+/- 50 cents)
        frequency = 5.5,       -- 5.5 Hz (cycles per second)
        sampleRate = 200,      -- 100 samples per second
        attackTime = attackTimeActive, -- 100ms attack for 0.1 and 0.5 = progressive vibrato
        releaseTime = 0.1,     -- 300ms release for 0.3
		frequencyModulation = frequencyModulationActive
        -- frequencyModulation = {5.5, 5.7, 6.0, 6.0, 6.0, 5.7} -- Frequency modulation
    }
    
    -- Generate vibrato points
    local vibratoPoints = self:applyVibratoToNote(
        noteStartTick, 
        noteDurationTicks, 
        ticksPerSecond, 
        vibratoDelay, 
        vibratoParams
    )
    
    -- Convert to control points -- 0.01 = 10ms default
    local controlPoints = self:exportVibratoToControlPoints(vibratoPoints, self.controlPointsMilliSeconds)
    
    -- -- Control points
    -- result = result .. "Vibrato control points:"
    -- for i, point in ipairs(controlPoints) do
        -- result = result .. string.format("Time: %.2fs, Value: %.4f", point.time, point.value)
		-- .. "\r"
    -- end
    
    return controlPoints
end

-- Add vibrato to selected notes
function NotesObject:addVibratoToSelectedNotes(model_choice, override_depth,
						override_FrequencyModel, override_start, override_rate,
						isProgressiveVibrato)

	local percentStartNote = self.vibratoModels[model_choice].startNote
	local modulationDepth = self.vibratoModels[model_choice].vibratoDepth
	local percentEndNote = self.vibratoModels[model_choice].endNote
	local frequencyModModel = self.vibratoModels[model_choice].frequencyModModel

	-- Loop all selected notes
	for k, note in pairs(self.selectedNotes) do
		local notePos = note:getOnset()
		local notePosEnd = note:getEnd()
		local noteDuration = note:getDuration()
		local paramPitchDelta = self.currentGroupNotes:getParameter(self.PARAMETER_REFERENCE)
		
		self.currentBPM = self:getProjectTempo(notePos)
		self.blicksPerSeconds, self.quarterBlicks = self:getCurrentBlicksPerSecond(notePos)
		
		if self.blicksPerSeconds == -1 then
			self:show(SV:T("ERROR! Tempo not found!"))
			break
		else
			-- Clear all previous pitchDelta parameters
			paramPitchDelta:remove(notePos, notePosEnd)
			
			local newModulationDepth = self.coefModulation * modulationDepth
			if override_depth ~= self.overrideDepthDefaultValue then
				newModulationDepth = self.coefModulation * override_depth
			end

			-- 1 == default frequency model
			if override_FrequencyModel ~= self.defaultVibratoModel then
				frequencyModModel = override_FrequencyModel - 1
			end
			local frequencyModModelActive = self.frequencyModModels[frequencyModModel]

			-- Override frequencyModModelActive
			if override_rate ~= self.overrideRateDefaultValue then
				frequencyModModelActive = {}
				table.insert(frequencyModModelActive, self.frequencyModulationDefault  * override_rate)
			end

			self.frequencyModModelActive = frequencyModModelActive
		
			local noteDurationSeconds = self.timeAxis:getSecondsFromBlick(noteDuration)
			local vibratoDelayInSeconds = noteDurationSeconds * percentStartNote / 100			
			if override_start ~= self.overrideStartDefaultValue then
				vibratoDelayInSeconds = noteDurationSeconds * override_start / 100
			end
			
			local notePosStart = 0 -- SV:seconds2Blick(0.02, self.currentBPM)
			if percentEndNote > 0 then
				local endNoteDurationSeconds = noteDurationSeconds * percentEndNote / 100
				local endNoteDuration = self.timeAxis:getBlickFromSeconds(endNoteDurationSeconds)
				noteDuration = noteDuration - endNoteDuration
			end
			
			-- Get vibrato points
			local points = self:getVibratoPoints(self.blicksPerSeconds, 
											notePosStart, noteDuration, 
											vibratoDelayInSeconds,
											frequencyModModelActive,
											isProgressiveVibrato)
			-- self:saveToClipboard(pointsString)
			self:addPointsToPitchDeltaParameter(notePos, points, newModulationDepth, paramPitchDelta)
		end
	end
end

-- Add points to pitch delta parameter
function NotesObject:addPointsToPitchDeltaParameter(notePos, points, modulationDepth, paramPitchDelta)
	-- Apply vibrato to pitchDelta parameters
	local newPos = notePos
	local isSimplify = false -- not used default
	
	for k, point in pairs(points) do
		newPos = notePos + self.timeAxis:getBlickFromSeconds(point.time)
		paramPitchDelta:add(newPos, point.value * modulationDepth)
	end

	-- Add a last point to stop pitch modulation
	newPos = newPos + self.timeGapBlicks
	paramPitchDelta:add(newPos, 0)
	
	
	if isSimplify then 
		local threshold = 0.01 -- 0.002 default
		paramPitchDelta:simplify(notePos, newPos, threshold)
	end
end

-- Create user input form
function NotesObject:getForm()
	
	local newVibratoModel = self.defaultVibratoModel
	local newFrequencyModel = self.defaultFrequencyModel
	local newProgressiveVibrato = self.progressiveVibrato
	local newOverrideDepthValue = self.overrideDepthDefaultValue
	local newOverrideRateValue = self.overrideRateDefaultValue
	local newOverrideStartValue = self.overrideStartDefaultValue
	local presetLabel = ""
	
	if #self.presetValues > 0 then
		newVibratoModel = self.presetValues[1].vibratoModel
		newFrequencyModel = self.presetValues[1].frequencyModel
		newOverrideDepthValue =  self.presetValues[1].overrideDepth
		newOverrideRateValue =  self.presetValues[1].overrideRate
		newOverrideStartValue = self.presetValues[1].overrideStart
		newProgressiveVibrato = self.presetValues[1].progressiveVibrato
		presetLabel = SV:T("Preset: ") .. self:getFileNameOnly(self.presetVibratoFileName)
	end
	
	local sliderOverrideDepth = {
			name = "overrideDepth", type = "Slider",
			label = SV:T("Override vibrato depth"),
			format = "%1.1f" .. " " .. SV:T("Depth"),
			minValue = self.overrideDepthMinValue, 
			maxValue = self.overrideDepthMaxValue, 
			interval = self.overrideDepthLevelInterval, 
			default  = newOverrideDepthValue
		}

	local sliderOverrideRate = {
			name = "overrideRate", type = "Slider",
			label = SV:T("Force rate and override frequency modulation"),
			format = "%1.1f" .. " " .. SV:T("Rate"),
			minValue = self.overrideRateMinValue, 
			maxValue = self.overrideRateMaxValue, 
			interval = self.overrideRateLevelInterval, 
			default  = newOverrideRateValue
		}
	
	local sliderOverrideStart = {
			name = "overrideStart", type = "Slider",
			label = SV:T("Override start note"),
			format = "%1.1f"  .. " " .. SV:T("%"),
			minValue = self.overrideStartMinValue, 
			maxValue = self.overrideStartMaxValue, 
			interval = self.overrideStartLevelInterval, 
			default  = newOverrideStartValue
		}
	
	local checkboxProgressiveVibrato = {
			name = "isProgressiveVibrato",
			text = SV:T("Progressive vibrato"),
			type = "CheckBox",
			default = newProgressiveVibrato
		}
	
	if #self.vibratoModelsList > 0 then
		vibratoComboChoice = {
			name = "vibratoModel", type = "ComboBox", label = SV:T("Select a vibrato model"), 
			choices = self.vibratoModelsList, default = newVibratoModel - 1
		}
	end

	if #self.frequencyModModelsList > 0 then
		-- Add a default value (not overrided)
		local frequencyModModelsList = {}
		table.insert(frequencyModModelsList, SV:T("Default model"))
		for _, freq in pairs(self.frequencyModModelsList) do
			table.insert(frequencyModModelsList, freq)
		end
		
		frequencyModelComboChoice = {
			name = "frequencyModel", type = "ComboBox", label = SV:T("Override a frequency model"), 
			choices = frequencyModModelsList, default = newFrequencyModel - 1
		}
	end
	
	local form = {
		title = SV:T(SCRIPT_TITLE),
		message = SV:T("Vibrato modulation") .. "\r",
		buttons = "OkCancel",
		widgets = {
			{
				name = "modulationReset", type = "TextArea", 
				label = SV:T("Do not forget to reset Vibrato Modulation to 0") .. "\r"
					.. SV:T("in the Notes Panel!"), 
				height = 0
			},
			vibratoComboChoice,
			frequencyModelComboChoice,
			sliderOverrideDepth,
			sliderOverrideStart,
			sliderOverrideRate,
			checkboxProgressiveVibrato,
			{
				name = "separator", type = "TextArea", label = presetLabel, height = 0
			},
		}
	}
	return SV:showCustomDialog(form)
end

-- Get preset content
function NotesObject:getPresetContent(presetContent)
	local presetValues = {}
	local preset = "" -- preset:
	local vibratoModel = self.modelSelected
	local frequencyModel = self.overrideFrequencyModelSelected
	local overrideDepth =  self.overrideDepthSelected
	local overrideRate = self.overrideRateSelected
	local overrideStart = self.overrideStartSelected
	
	if #presetContent > 0 then
		preset = self:split(presetContent, ":")[2] -- preset:
		if #preset > 0 then
			local tagPreset = self:split(preset, ",") -- progressiveVibrato=false,..
			for _, tagItem in pairs(tagPreset) do
				local tagContent = self:split(tagItem, "=") -- progressiveVibrato=false
				local tagName = tagContent[1]
				local tagValue = tagContent[2]
				
				if tagName == "progressiveVibrato" then
					progressiveVibrato = (tagValue == "true")
				end
				if tagName == "vibratoModel" then
					vibratoModel = tonumber(tagValue)
				end
				if tagName == "frequencyModel" then
					frequencyModel = tonumber(tagValue)
				end
				if tagName == "overrideDepth" then
					overrideDepth =  tonumber(tagValue)
				end
				if tagName == "overrideRate" then
					overrideRate = tonumber(tagValue)
				end
				if tagName == "overrideStart" then
					overrideStart = tonumber(tagValue)
				end
			end
			
			table.insert(presetValues, {
				progressiveVibrato = progressiveVibrato, 
				vibratoModel = vibratoModel,
				frequencyModel = frequencyModel,
				overrideDepth = overrideDepth,
				overrideRate = overrideRate,
				overrideStart = overrideStart
				})
		end
	end
	return presetValues
end

-- Set data preset
function NotesObject:setDataPreset()
	local presetContent = "Preset1:"
	presetContent = presetContent .. "progressiveVibrato=" .. tostring(self.progressiveVibrato)  .. ","
	presetContent = presetContent .. "vibratoModel=" .. self.modelSelected  .. ","
	presetContent = presetContent .. "frequencyModel=" .. self.overrideFrequencyModelSelected  .. ","
	presetContent = presetContent .. "overrideDepth=" .. self.overrideDepthSelected  .. ","
	presetContent = presetContent .. "overrideRate=" .. self.overrideRateSelected  .. ","
	presetContent = presetContent .. "overrideStart=" .. self.overrideStartSelected
	
	return presetContent
end

-- Start process
function NotesObject:start()
	if self.isPresetSave then
		self.presetRecord = self:readPresetFromTextFile(self.presetVibratoFileName)
		self.presetValues = self:getPresetContent(self.presetRecord)
	end

	local userInput = self:getForm()
	
	if userInput.status then
		if userInput.answers.vibratoModel ~= nil then
			self.modelSelected = userInput.answers.vibratoModel + 1 -- see self.vibratoModel
			self.overrideDepthSelected = userInput.answers.overrideDepth
			self.overrideRateSelected = userInput.answers.overrideRate
			self.overrideFrequencyModelSelected = userInput.answers.frequencyModel + 1
			self.overrideStartSelected = userInput.answers.overrideStart
			
			self.progressiveVibrato = userInput.answers.isProgressiveVibrato

			self:addVibratoToSelectedNotes(self.modelSelected, self.overrideDepthSelected, 
				self.overrideFrequencyModelSelected, self.overrideStartSelected, 
				self.overrideRateSelected, self.progressiveVibrato)
			
			if self.isPresetSave then
				self.presetContent = self:setDataPreset()
				self:savePresetToTextFile(self.presetContent, self.presetVibratoFileName)
			end
		end
		self:start()
	else
		SV:finish()
	end
end

-- Main process
function main()
	local notesObject = NotesObject:new()
	notesObject:start()
end